> 当前位置：【Java】04_JavaWeb  -> 4.2_ 数据库_ 00_数据库基础

----



# 第一章 数据库 概述

## 1、数据库简介

- 概念

```java
- 数据库(Database)是按照数据结构来组织、存储和管理数据的仓库
- 数据库是对大量信息进行管理的高效解决方案，按照数据结构来组织，存储和管理数据的库
    
DBS = DBMS + DB
数据库系统（DBS，DateBaseSystem）= 数据库管理系统（DBMS，DataBaseManagementSystem）+ 数据库（DataBase）
```

- 常见数据库

```java
- Oracle
- MySQL
- SQL Server（Windows）
- DB2（IBM）
- Postgre SQL
```



关系型数据库系统：建立在关系模型上的数据库系统。

关系模型：当将日常生活中的实体和实体的属性保存到数据中的时候如何处理该实体结构

①	数据结构可以规定（将导致同类结构，结构一致，就是一个二维表格）

②	数据之间的关系可以设置








	SQL语言
		Structured Query Language：结构化查询语言
			DDL
				数据定义语言
			DML
				数据操作语言
			DQL
				数据查询语言
			DCL
				数据控制语言



# 第二章 数据库 连接池

- C3P0
- DBCP



# 第三章 数据库 事务

## 1、事务的概念

指逻辑上的⼀组操作，组成这组操作的各个单元，要么全部成功，要么全部不成功，从⽽确保了数据的准确与安全



## 2、事务的四大特性

```java
原⼦性（Atomicity） 
- 指事务是⼀个不可分割的⼯作单位，事务中的操作要么都发⽣，要么都不发⽣
- 从操作的⻆度来描述，事务中的各个操作要么都成功要么都失败

⼀致性（Consistency） 
- 事务必须使数据库从⼀个⼀致性状态变换到另外⼀个⼀致性状态
- 例如转账前A有1000，B有1000。转账后A+B也得是2000

隔离性（Isolation） 
- 事务的隔离性是多个⽤户并发访问数据库时，数据库为每⼀个⽤户开启的事务，每个事务不能被其他事务的操作数据所⼲扰，多个并发事务之间要相互隔离。
- ⽐如：事务1给员⼯涨⼯资2000，但是事务1尚未被提交，员⼯发起事务2查询⼯资，发现⼯资涨了2000块钱，读到了事务1尚未提交的数据（脏读）

持久性（Durability）
- 指⼀个事务⼀旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发⽣故障也不应该对其有任何影响
```



## 3、事务的隔离级别

- 隔离级别在解决事务并发问题，不考虑隔离级别，会出现以下情况：（以下情况全是错误的）

### 3.1 脏读 和 不可重复读

```java
脏读：⼀个线程中的事务读到了另外⼀个线程中 未提交 的数据
不可重复读：⼀个线程中的事务读到了另外⼀个线程中已经提交的 update 的数据（前后内容不⼀样）

场景：
员⼯A发起事务1，查询⼯资，⼯资为1w，此时事务1尚未关闭
财务⼈员发起了事务2，给员⼯A张了2000块钱，并且提交了事务
员⼯A通过事务1再次发起查询请求，发现⼯资为1.2w，原来读出来1w读不到了，叫做不可重复读
```

### 3.2 虚读（幻读）

```java
虚读（幻读）：⼀个线程中的事务读到了另外⼀个线程中已经提交的insert或者delete的数据（前后条数不⼀样）

场景：
事务1查询所有⼯资为1w的员⼯的总数，查询出来了10个⼈，此时事务尚未关闭
事务2财务⼈员发起，新来员⼯，⼯资1w，向表中插⼊了2条数据，并且提交了事务
事务1再次查询⼯资为1w的员⼯个数，发现有12个⼈
```



### 3.3 数据库四种隔离级别

- 注意：级别依次降低，效率依次升高

```java
Serializable（串⾏化） --------------- 最高级别，效率最低
- 可避免脏读、不可重复读、虚读情况的发⽣
  
Repeatable read（可重复读）
- 可避免脏读、不可重复读情况的发⽣(幻读有可能发⽣)
- 该机制下会对要 update 的⾏进⾏加锁
  
Read committed（读已提交）
- 可避免脏读情况发⽣
- 不可重复读和幻读⼀定会发⽣ 
  
Read uncommitted（读未提交） --------------- 最低级别，效率最高
- 最低级别，以上情况均⽆法保证
```



## 4、事务的传播行为

### 4.1 概念

```java
- 事务往往在 service 层进⾏控制，如果出现 service 层⽅法 A 调⽤了另外⼀个 service 层⽅法B，A和B⽅法本身都已经被添加了事务控制
- 那么A调⽤B的时候，就需要进⾏事务的⼀些协商，这就叫做事务的传播⾏为
```



### 4.2 传播行为

- A调⽤B，站在B的⻆度来观察来定义事务的传播⾏为

```java
PROPAGATION_REQUIRED
- 如果当前没有事务，就新建⼀个事务，如果已经存在⼀个事务中，加⼊到这个事务中。这是最常⻅的选择。
  
PROPAGATION_SUPPORTS
- ⽀持当前事务，如果当前没有事务，就以⾮事务⽅式执⾏。
  
PROPAGATION_MANDATORY 
- 使⽤当前的事务，如果当前没有事务，就抛出异常。
  
PROPAGATION_REQUIRES_NEW 
- 新建事务，如果当前存在事务，把当前事务挂起。
  
PROPAGATION_NOT_SUPPORTED 
- 以⾮事务⽅式执⾏操作，如果当前存在事务，就把当前事务挂起。
  
PROPAGATION_NEVER 
- 以⾮事务⽅式执⾏，如果当前存在事务，则抛出异常。
  
PROPAGATION_NESTED 
- 如果当前存在事务，则在嵌套事务内执⾏。如果当前没有事务，则执⾏与PROPAGATION_REQUIRED类似的操作。
```





