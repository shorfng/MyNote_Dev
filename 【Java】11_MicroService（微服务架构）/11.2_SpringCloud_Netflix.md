> 当前位置：【Java】11_MicroService（微服务）-> 11.2_SpringCloud_Netflix

# SpringCloud_Netflix 组件

|                | 第⼀代 Spring Cloud Netflix（SCN）                | 第⼆代 Spring Cloud Alibaba（SCA）             |
| -------------- | ------------------------------------------------- | ---------------------------------------------- |
| 服务注册中心   | Netflix Eureka                                    | 阿里巴巴：Nacos                                |
| 客户端负载均衡 | Netflix Ribbon                                    | 阿⾥巴巴：Dubbo RPC、SpringCloud：Loadbalancer |
| 服务熔断       | Netflix Hystrix                                   | 阿⾥巴巴：Sentinel                             |
| 远程服务调用   | Netflix Feign                                     | 阿⾥巴巴：Dubbo RPC                            |
| 网关           | Netflix Zuul（已退出）、==Spring Cloud：Gateway== | ==Spring Cloud：Gateway==                      |
| 服务配置中心   | Spring Cloud Config + Spring Cloud Bus            | 阿⾥巴巴：Nacos、携程：Apollo                  |
| 消息驱动       | ==Spring Cloud Stream==                           | ==Spring Cloud Stream==                        |
| 分布式链路追踪 | ==Spring Cloud Sleuth + Twitter Zipkin==          | ==Spring Cloud Sleuth + Twitter Zipkin==       |
| 统一认证方案   | ==Spring Cloud OAuth2 + JWT==                     | ==Spring Cloud OAuth2 + JWT==                  |
| 分布式事务方案 |                                                   | 阿里巴巴：seata                                |



- 从形式上来说，Feign = RestTemplate + Ribbon + Hystrix

![image-20211108144356278](image/image-20211108144356278.png)



# 第一章 服务注册中心 - Netflix Eureka

## 1、Eureka 基础架构

![image-20211108161707124](image/image-20211108161707124.png)



## 2、Eureka 交互流程及原理





## 3、搭建流程 - Eureka（单例）

### 步骤1：pom.xml 

#### （1）SpringCloud 父工程 pom.xml 引入 Spring Cloud 依赖

```xml
<dependencyManagement>
  <dependencies>
    <!-- SpringCloud 依赖管理 -->
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-dependencies</artifactId>
      <version>Greenwich.RELEASE</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```



#### （2）SpringCloud 父工程 pom.xml 手动引入 jaxb 的jar包

- 因为Jdk9之后默认没有加载该模块，EurekaServer使⽤到，所以需要⼿动导⼊，否则EurekaServer服务⽆法启动

```xml
<!-- eureka server 需要引入Jaxb，开始 -->
<dependency>
  <groupId>com.sun.xml.bind</groupId>
  <artifactId>jaxb-core</artifactId>
  <version>2.2.11</version>
</dependency>

<dependency>
  <groupId>javax.xml.bind</groupId>
  <artifactId>jaxb-api</artifactId>
</dependency>

<dependency>
  <groupId>com.sun.xml.bind</groupId>
  <artifactId>jaxb-impl</artifactId>
  <version>2.2.11</version>
</dependency>

<dependency>
  <groupId>org.glassfish.jaxb</groupId>
  <artifactId>jaxb-runtime</artifactId>
  <version>2.2.10-b140310.1920</version>
</dependency>

<dependency>
  <groupId>javax.activation</groupId>
  <artifactId>activation</artifactId>
  <version>1.1.1</version>
</dependency>
<!-- 引入Jaxb，结束 -->
```



#### （3）当前子工程  pom.xml 引入 Eureka server 依赖

```xml
<dependencies>
  <!-- Eureka server依赖 -->
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
  </dependency>
</dependencies>
```



### 步骤2：application.yml 配置文件

- 当前子工程  application.yml 配置

```yaml
# eureka server服务端口
server:
  port: 8761

spring:
  application:
    # 应用服务名称（会在Eureka中作为服务名称）
    name: cloud-eureka-server

# eureka 客户端配置（用于和Server交互），Eureka Server 其实也是一个 Client
eureka:
  instance:
    # 当前 eureka 实例的主机名
    hostname: localhost
  client:
    service-url:
      # 配置客户端所交互的 Eureka Server 地址
      # Eureka Server集群中每一个Server其实相对于其它Server来说都是Client
      # 单机模式下
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka
    # 是否禁止自己当做服务注册（集群模式下，可以改成 true）
    register-with-eureka: false
    # 是否屏蔽注册信息（默认为 true）
    # 单机模式下，自己就是 server，不需要从 EurekaServer 获取服务信息
    # 集群模式下，改成 true
    fetch-registry: false
  # 是否启用eureka服务控制台
  dashboard:
    enabled: true
```



### 步骤3：SpringBoot 启动类

- 使⽤ @EnableEurekaServer 声明当前项目为 EurekaServer 服务

```java
@SpringBootApplication
@EnableEurekaServer  // 声明当前项目为Eureka服务
public class CloudEurekaServer8761Application {
    public static void main(String[] args) {
        SpringApplication.run(CloudEurekaServer8761Application.class, args);
    }
}
```



## 4、搭建流程 - Eureka Server HA（高可用集群）

![image-20211108200007419](image/image-20211108200007419.png)

### 步骤1：pom.xml 

#### （1）SpringCloud 父工程 pom.xml 引入 Spring Cloud 依赖

```xml
<dependencyManagement>
  <dependencies>
    <!-- SpringCloud 依赖管理 -->
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-dependencies</artifactId>
      <version>Greenwich.RELEASE</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```



#### （2）SpringCloud 父工程 pom.xml 手动引入 jaxb 的jar包

- 因为Jdk9之后默认没有加载该模块，EurekaServer使⽤到，所以需要⼿动导⼊，否则EurekaServer服务⽆法启动

```xml
<!-- eureka server 需要引入Jaxb，开始 -->
<dependency>
  <groupId>com.sun.xml.bind</groupId>
  <artifactId>jaxb-core</artifactId>
  <version>2.2.11</version>
</dependency>

<dependency>
  <groupId>javax.xml.bind</groupId>
  <artifactId>jaxb-api</artifactId>
</dependency>

<dependency>
  <groupId>com.sun.xml.bind</groupId>
  <artifactId>jaxb-impl</artifactId>
  <version>2.2.11</version>
</dependency>

<dependency>
  <groupId>org.glassfish.jaxb</groupId>
  <artifactId>jaxb-runtime</artifactId>
  <version>2.2.10-b140310.1920</version>
</dependency>

<dependency>
  <groupId>javax.activation</groupId>
  <artifactId>activation</artifactId>
  <version>1.1.1</version>
</dependency>
<!-- 引入Jaxb，结束 -->
```



#### （3）当前子工程  pom.xml 引入 Eureka server 依赖

```xml
<dependencies>
  <!-- Eureka server依赖 -->
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
  </dependency>
</dependencies>
```



### 步骤2：application.yml 配置文件

#### （1）当前子工程  application.yml 配置 - CloudEurekaServerA

```yaml
# eureka server服务端口
server:
  port: 8761

spring:
  application:
    # 应用服务名称（会在Eureka中作为服务名称）
    name: cloud-eureka-server

# eureka 客户端配置（用于和Server交互），Eureka Server 其实也是一个 Client
eureka:
  instance:
    # 当前 eureka 实例的主机名
    hostname: CloudEurekaServerA
  client:
    service-url:
      # 配置客户端所交互的 Eureka Server 地址
      # Eureka Server集群中每一个Server其实相对于其它Server来说都是Client
      # 单机模式下
      # defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka
      # 集群模式下，defaultZone 应该指向其它 Eureka Server，如果有更多其它Server实例，逗号拼接即可
      defaultZone: http://CloudEurekaServerB:8762/eureka
    # 是否禁止自己当做服务注册（集群模式下，可以改成 true）
    register-with-eureka: true
    # 是否屏蔽注册信息（默认为 true）
    # 单机模式下，自己就是 server，不需要从 EurekaServer 获取服务信息
    # 集群模式下，改成 true
    fetch-registry: true
  # 是否启用eureka服务控制台
  dashboard:
    enabled: true
```

#### （2）当前子工程  application.yml 配置 - CloudEurekaServerB

```yaml
# eureka server服务端口
server:
  port: 8762

spring:
  application:
    # 应用服务名称（会在Eureka中作为服务名称）
    name: cloud-eureka-server

# eureka 客户端配置（用于和Server交互），Eureka Server 其实也是一个 Client
eureka:
  instance:
    # 当前 eureka 实例的主机名
    hostname: CloudEurekaServerB
  client:
    service-url:
      # 配置客户端所交互的 Eureka Server 地址
      # Eureka Server集群中每一个Server其实相对于其它Server来说都是Client
      # 单机模式下
      # defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka
      # 集群模式下，defaultZone 应该指向其它 Eureka Server，如果有更多其它Server实例，逗号拼接即可
      defaultZone: http://CloudEurekaServerA:8761/eureka
    # 是否禁止自己当做服务注册（集群模式下，可以改成 true）
    register-with-eureka: true
    # 是否屏蔽注册信息（默认为 true）
    # 单机模式下，自己就是 server，不需要从 EurekaServer 获取服务信息
    # 集群模式下，改成 true
    fetch-registry: true
  # 是否启用eureka服务控制台
  dashboard:
    enabled: true
```



### 步骤3：SpringBoot 启动类

#### （1）使用 @EnableEurekaServer 声明当前项目为 EurekaServer 服务 - CloudEurekaServer8761Application

```java
@SpringBootApplication
@EnableEurekaServer  // 声明当前项目为Eureka服务
public class CloudEurekaServer8761Application {
    public static void main(String[] args) {
        SpringApplication.run(CloudEurekaServer8761Application.class, args);
    }
}
```

#### （2）使用 @EnableEurekaServer 声明当前项目为 EurekaServer 服务 - CloudEurekaServer8762Application

```java
@SpringBootApplication
@EnableEurekaServer  // 声明当前项目为Eureka服务
public class CloudEurekaServer8762Application {
    public static void main(String[] args) {
        SpringApplication.run(CloudEurekaServer8762Application.class, args);
    }
}
```



### 步骤4：修改本机 host 内容

```properties
# Eureka配置server集群
127.0.0.1 CloudEurekaServerA
127.0.0.1 CloudEurekaServerB
```



## 5、Eureka 服务控制台详解

![image-20211108200515404](image/image-20211108200515404.png)

![image-20211108201436183](image/image-20211108201436183.png)



## 6、使用流程 - 将服务提供者注册到 Eureka 服务中心

### 步骤1：pom.xml 

#### （1）父工程中引入 spring-cloud-commons 依赖

```xml
<!-- spring cloud commons模块引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-commons</artifactId>
</dependency>
```

#### （2）子工程中引入 eureka client 客户端依赖

```xml
<!-- eureka client 客户端依赖引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```



### 步骤2：配置 application.yml 文件

```yaml
server:
  port: 8080

spring:
  application:
    name: resume-service-resume
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/SpringCloud?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC
    username: root
    password: root
  jpa:
    database: MySQL
    show-sql: true
    hibernate:
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl  #避免将驼峰命名转换为下划线命名

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



### 步骤3：启动类添加注解

```java
@SpringBootApplication
@EntityScan("com.loto.pojo")

// 说明：从 SpringCloud Edgware 版本开始，不加注解也可以，但是建议加上
// 方式1：开启 Eureka Client（使用 Eureka 作为注册中心时）
//@EnableEurekaClient

// 方式2：开启注册中心客户端 （通用型注解，使用Eureka或者Nacos等作为注册中心时使用）
@EnableDiscoveryClient
public class ResumeApplication8080 {
    public static void main(String[] args) {
        SpringApplication.run(ResumeApplication8080.class,args);
    }
}
```



## 7、使用流程 - 将服务消费者注册到 Eureka 服务中心

### 步骤1：pom.xml 

#### （1）父工程中引入 spring-cloud-commons 依赖

```xml
<!-- spring cloud commons模块引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-commons</artifactId>
</dependency>
```

#### （2）子工程中引入 eureka client 客户端依赖

```xml
<!-- eureka client 客户端依赖引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```



### 步骤2：配置 application.yml 文件

```yaml
server:
  port: 8081

spring:
  application:
    name: resume-service-autodeliver

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



### 步骤3：启动类添加注解

```java
@SpringBootApplication
@EnableDiscoveryClient
public class AutodeliverApplication8081 {
    public static void main(String[] args) {
        SpringApplication.run(AutodeliverApplication8081.class, args);
    }

    // 使用 RestTemplate 模板对象进行远程调用
    @Bean
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
```



## 8、使用流程 - 服务消费者 调用 服务提供者（通过Eureka）

```java
@RestController
@RequestMapping("/autodeliver")
public class AutodeliverController {
    // RestTemplate 模板对象（Rest 风格的远程服务调用）
    @Autowired
    private RestTemplate restTemplate;

    // 注入服务发现客户端
    @Autowired
    private DiscoveryClient discoveryClient;

    //http://localhost:8081/autodeliver/checkState/1545132
    /**
     * 服务注册到 Eureka 之后的改造：从注册中心拿服务实例，进行访问
     */
    @GetMapping("/checkState/{userId}")
    public Integer findResumeOpenState(@PathVariable Long userId) {
        // 1、从 Eureka Server 中获取 resume-service-resume 服务的实例信息（使用客户端对象做这件事）
        List<ServiceInstance> instances = discoveryClient.getInstances("resume-service-resume");

        // 2、如果有多个实例，选择一个使用(负载均衡的过程)
        ServiceInstance serviceInstance = instances.get(0);

        // 3、从元数据信息获取 host、port
        String host = serviceInstance.getHost();
        int port = serviceInstance.getPort();
        String url = "http://" + host + ":" + port + "/resume/openstate/" + userId;
        System.out.println("===============>>>从EurekaServer集群获取服务实例拼接的url：" + url);

        // 调用远程服务（简历微服务接口） - RestTemplate
        Integer forObject = restTemplate.getForObject(url, Integer.class);
        return forObject;
    }
}
```



## 9、Eureka 元数据

### （1）分类

- 标准元数据：主机名、IP地址、端⼝号等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用
- 自定义元数据：可以使用 eureka.instance.metadata-map 配置，符合 KEY/VALUE 的存储格式。这些元数据可以在远程客户端中访问



### （2）自定义元数据的配置

- application.yml（resume-service-resume-8080）

```yaml
# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
    metadata-map:
      cluster: cl1
      region: rn1
```



### （3）获取自定义元数据

- resume-service-autodeliver-8081

- http://localhost:8081/autodeliver/metadata

```java
/**
 * 获取 Eureka 元数据
 */
@GetMapping("/metadata")
public void testInstanceMetadata() {
    List<ServiceInstance> instances = discoveryClient.getInstances("resume-service-resume");

    // 自定义的元数据的值
    System.out.println(instances.get(0).getMetadata().get("cluster"));
    System.out.println(instances.get(0).getMetadata().get("region"));
    System.out.println("=============================");

    // 所有实例
    for (int i = 0; i < instances.size(); i++) {
        ServiceInstance serviceInstance =  instances.get(i);
        System.out.println(serviceInstance);
    }
}
```



## 10、Eureka 源码分析

### 10.1 Eureka Server 启动过程

### 10.2 Eureka Server 服务接口暴露策略

### 10.3 Eureka Server 服务注册接口（接受客户端注册服务）

### 10.4 Eureka Server 服务续约接口（接受客户端续约）

### 10.5 Eureka Client 注册服务

### 10.6 Eureka Client 下架服务

### 10.7 Eureka Client 心跳续约



# 第二章 客户端负载均衡 - Netflix Ribbon

## 1、Ribbon 简介

- 负载均衡⼀般分为服务器端负载均衡和客户端负载均衡

```
- 服务器端负载均衡，⽐如Nginx、F5这些，请求到达服务器之后由这些负载均衡器根据⼀定的算法将请求路由到⽬标服务器处理。
- 客户端负载均衡，⽐如Ribbon，服务消费者客户端会有⼀个服务器地址列表，调⽤⽅在请求前通过⼀定的负载均衡算法选择⼀个服务器进⾏访问，负载均衡算法的执⾏是在请求客户端进⾏。
```

- Ribbon是Netflix发布的负载均衡器
- Eureka⼀般配合Ribbon进⾏使⽤
- Ribbon利⽤从Eureka中读取到服务信息，在调⽤服务提供者提供的服务时，会根据⼀定的算法进⾏负载。



## 2、Ribbon 负载均衡策略

- 负责负载均衡的顶级接口：com.netflflix.loadbalancer.IRule



### 2.1 RoundRobinRule：轮询策略

- 默认超过10次获取到的server都不可⽤，会返回⼀个空的server



### 2.2 RandomRule：随机策略

- 如果随机到的server为null或者不可⽤的话，会while不停的循环选取



### 2.3 RetryRule：重试策略

- ⼀定时限内循环重试
- 默认继承RoundRobinRule，也⽀持⾃定义注⼊
- RetryRule会在每次选取之后，对选举的server进⾏判断，是否为null，是否alive，并且在500ms内会不停的选取判断，RandomRule是没有失效时间的概念，只要serverList没都挂。



### 2.4 BestAvailableRule：最小连接数策略

- 遍历serverList，选取出可⽤的且连接数最⼩的⼀个server
- 该算法⾥⾯有⼀个LoadBalancerStats的成员变量，会存储所有server的运⾏状况和连接数
- 如果选取到的server为null，那么会调⽤RoundRobinRule重新选取



### 2.5 AvailabilityFilteringRule：可用过滤策略

- 扩展了轮询策略
- 会先通过默认的轮询选取⼀个server，再去判断该server是否超时可⽤，当前连接数是否超限，都成功（即可用，且没有超限）再返回



### 2.6 ZoneAvoidanceRule：区域权衡策略（默认策略）

- 扩展了轮询策略
- 继承了2个过滤器：ZoneAvoidancePredicate 和 AvailabilityPredicate
- 除了过滤超时和链接数过多的server，还会过滤掉不符合要求的 zone 区域⾥⾯的所有节点



## 3、Ribbon 使用

### 步骤1：pom.xml 依赖

- eureka-client 依赖会引入 Ribbon 相关的 jar

```xml
<!-- eureka client 客户端依赖引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```



### 步骤2：启动类添加注解 @LoadBalanced

- 在 RestTemplate 上添加对应注解

```java
@SpringBootApplication
@EnableDiscoveryClient
public class AutodeliverApplication8081 {
    public static void main(String[] args) {
        SpringApplication.run(AutodeliverApplication8081.class, args);
    }

    // 使用 RestTemplate 模板对象进行远程调用
    @Bean
    @LoadBalanced // Ribbon 负载均衡
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
```



### 步骤3：修改负载均衡策略

- 方式1：针对的被调用方微服务名称

```yaml
resume-service-resume:
  ribbon:
    # 负载策略调整：使用轮询
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
```

- 方式2：全局生效

```yaml
ribbon:
	# 负载策略调整：使用轮询
	NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule 
```



### 步骤4：使用 Ribbon 负载均衡

```java
@RestController
@RequestMapping("/autodeliver")
public class AutodeliverController {
    // RestTemplate 模板对象（Rest 风格的远程服务调用）
    @Autowired
    private RestTemplate restTemplate;

    // 注入服务发现客户端
    @Autowired
    private DiscoveryClient discoveryClient;

    //http://localhost:8081/autodeliver/checkState3/1545132
    /**
     * 使用 Ribbon 负载均衡
     */
    @GetMapping("/checkState3/{userId}")
    public Integer findResumeOpenState3(@PathVariable Long userId) {
        // 指定服务名
        String url = "http://resume-service-resume/resume/openstate/" + userId;
        Integer forObject = restTemplate.getForObject(url, Integer.class);
        return forObject;
    }
}
```



## 4、Ribbon 工作原理

- 负载均衡管理器 LoadBalancer（总的协调者，相当于⼤脑，为了做事情，协调四肢）

```
围绕负载均衡管理器 LoadBalancer 周围的：
- IRule：是在选择实例的时候的负载均衡策略对象
- IPing：是⽤来向服务发起⼼跳检测的，通过⼼跳检测来判断该服务是否可⽤
- ServerListFilter：根据⼀些规则过滤传⼊的服务实例列表
- ServerListUpdater：定义了⼀系列的对服务列表的更新操作
```



## 5、Ribbon 源码分析

### 5.1 源码分析 - @LoadBalanced

#### （1）LoadBalanced.java

```java
// Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient.
// 使用 @LoadBalanced 注解后，可以将普通的 RestTemplate 对象使用 LoadBalancerClient 去处理
@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Qualifier
public @interface LoadBalanced {
}
```



#### （2）spring.factories

- 根据 SpringBoot 自动装配，找到 spring.factories 配置文件

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.cloud.netflix.ribbon.RibbonAutoCon
```



![image-20211109210254775](image/image-20211109210254775.png)



#### （3）RibbonAutoConfiguration.java

```java
@Configuration
@Conditional(RibbonAutoConfiguration.RibbonClassesConditions.class)
@RibbonClients
// 自动装配后
@AutoConfigureAfter(name = "org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration")
// 自动装配前
@AutoConfigureBefore({LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class})
@EnableConfigurationProperties({RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class})
public class RibbonAutoConfiguration {
	.....
}
```



#### （4）LoadBalancerAutoConfiguration.java

```java
@Configuration
// 只有存在 RestTemplate 这个类的时候，配置类才装配生效
@ConditionalOnClass(RestTemplate.class)
@ConditionalOnBean(LoadBalancerClient.class)
@EnableConfigurationProperties(LoadBalancerRetryProperties.class)
public class LoadBalancerAutoConfiguration {
  // 注⼊ RestTemplate 对象到集合
  // 声明了一个 List<RestTemplate> 集合对象，此处会自动注入拿些添加了 @LoadBalanced 注解的 RestTemplate 对象
  @LoadBalanced
  @Autowired(required = false)
  private List<RestTemplate> restTemplates = Collections.emptyList();

  // 使⽤定制器给集合中的每⼀个 RestTemplate 对象添加⼀个拦截器
	@Bean
	public SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(
			final ObjectProvider<List<RestTemplateCustomizer>> restTemplateCustomizers) {
		return () -> restTemplateCustomizers.ifAvailable(customizers -> {
            for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) {
                for (RestTemplateCustomizer customizer : customizers) {
                    // 定制
                    customizer.customize(restTemplate);
                }
            }
        });
	}
    
  @Configuration
	@ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")
	static class LoadBalancerInterceptorConfig {
		@Bean
		public LoadBalancerInterceptor ribbonInterceptor(LoadBalancerClient loadBalancerClient,LoadBalancerRequestFactory requestFactory) {
			return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);
		}
    
    // 注⼊ RestTemplate 定制器
		@Bean
		@ConditionalOnMissingBean
		public RestTemplateCustomizer restTemplateCustomizer(final LoadBalancerInterceptor loadBalancerInterceptor) {
        return restTemplate -> {
            List<ClientHttpRequestInterceptor> list = new ArrayList<>(restTemplate.getInterceptors());
          	// 向容器注入 RestTemplate 定制器（给 RestTemplate 对象添加一个拦截器 loadBalancerInterceptor）
            list.add(loadBalancerInterceptor);
            restTemplate.setInterceptors(list);
        };
    }
	}
  
  .......
  
}
```



#### （5）LoadBalancerInterceptor.java

```java
@Override
public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,final ClientHttpRequestExecution execution) throws IOException {
   // 获取拦截到的请求 URI
   final URI originalUri = request.getURI();
  
   // 获取 URI 中的服务名
   String serviceName = originalUri.getHost();
   Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);
  
   // 交给 LoadBalancerClient 对象负责执行（实现类是 RibbonLoadBalancerClient 对象）
   return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));
}
```



#### （6）LoadBalancerClient.java

- LoadBalancerClient 的实现类是 RibbonLoadBalancerClient

```java
// LoadBalancerClient.java
public interface LoadBalancerClient extends ServiceInstanceChooser {
   // 根据服务执⾏请求内容
   <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException;
   
   // 根据服务执⾏请求内容
   <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException;

   // 拼接请求⽅式 传统中是ip:port 现在是服务名称:port 形式
   URI reconstructURI(ServiceInstance instance, URI original);
}
```

- RibbonLoadBalancerClient 对象是在自动配置类 RibbonAutoConfiguration 中注入的

```java
// RibbonAutoConfiguration.java
@Bean
@ConditionalOnMissingBean(LoadBalancerClient.class)
public LoadBalancerClient loadBalancerClient() {
   return new RibbonLoadBalancerClient(springClientFactory());
}
```



#### （7）RibbonLoadBalancerClient.java

- LoadBalancerClient  中的 execute 实现方法

```java
@Override
public <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException {
    return execute(serviceId, request, null);
}

public <T> T execute(String serviceId, LoadBalancerRequest<T> request, Object hint) throws IOException {
  // 获取一个负载均衡对象
  ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
 
  // 通过负载均衡器选择一个最终要使用的 server 实例对象
  Server server = getServer(loadBalancer, hint);
  
  if (server == null) {
    throw new IllegalStateException("No instances available for " + serviceId);
  }
  
  // 把 server 封装成 RibbonServer 对象
  RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server,serviceId),serverIntrospector(serviceId).getMetadata(server));

  // 继续执行
  return execute(serviceId, ribbonServer, request);
}
```



##### 关注点1：追踪 getLoadBalancer 方法

```java
protected ILoadBalancer getLoadBalancer(String serviceId) {
   return this.clientFactory.getLoadBalancer(serviceId);
}

public ILoadBalancer getLoadBalancer(String name) {
	return getInstance(name, ILoadBalancer.class);
}
```



##### 关注点2：追踪 getServer 方法

```java
protected Server getServer(ILoadBalancer loadBalancer, Object hint) {
   if (loadBalancer == null) {
      return null;
   }
  
   // Use 'default' on a null hint, or just pass it on?
   return loadBalancer.chooseServer(hint != null ? hint : "default");
}
```

- 追踪 chooseServer 方法（ILoadBalancer.java）

```java
public Server chooseServer(Object key);
```

- 追踪 chooseServer 的实现方法，在 ZoneAwareLoadBalancer.java

```java
@Override
public Server chooseServer(Object key) {
    if (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() <= 1) {
        logger.debug("Zone aware logic disabled or there is only one zone");
        return super.chooseServer(key);
    }
    ......
}
```

- 追踪 chooseServer 方法，在父类 BaseLoadBalancer.java 中

```java
public Server chooseServer(Object key) {
    if (counter == null) {
        counter = createCounter();
    }
  
    counter.increment();
    if (rule == null) {
        return null;
    } else {
        try {
            // 使用负载均衡策略选择一个实例，摸的是区域隔离策略
            return rule.choose(key);
        } catch (Exception e) {
            logger.warn("LoadBalancer [{}]:  Error choosing server for key {}", name, key, e);
            return null;
        }
    }
}
```

- 追踪 choose 方法

```java
public Server choose(Object key);
```

- 追踪 choose  方法，在实现类 PredicateBasedRule.java 中

```java
@Override
public Server choose(Object key) {
    ILoadBalancer lb = getLoadBalancer();
  
    // 从过滤之后的服务实例集合中，根据轮询策略选择一个 server
    Optional<Server> server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);
    
    if (server.isPresent()) {
        return server.get();
    } else {
        return null;
    }       
}
```

- 追踪 chooseRoundRobinAfterFiltering 方法，来到 AbstractServerPredicate.java 

```java
public Optional<Server> chooseRoundRobinAfterFiltering(List<Server> servers, Object loadBalancerKey) {
    List<Server> eligible = getEligibleServers(servers, loadBalancerKey);
    if (eligible.size() == 0) {
        return Optional.absent();
    }
  
    // 轮询到的实例索引值计算方法
    return Optional.of(eligible.get(incrementAndGetModulo(eligible.size())));
}

.....
  
private int incrementAndGetModulo(int modulo) {
  for (;;) {
    // 获取当前服务实例的索引值
    int current = nextIndex.get();
    
    // 通过求余的方式记录下一个索引值
    int next = (current + 1) % modulo;
    
    // 通过 compareAndSet 设置下一个索引值（解决并发场景下，可能造成的数据问题）
    if (nextIndex.compareAndSet(current, next) && current < modulo)
      return current;
  }
}
```



##### 关注点3：追踪 execute 方法

```java
@Override
public <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException {
   Server server = null;
  
   if(serviceInstance instanceof RibbonServer) {
      server = ((RibbonServer)serviceInstance).getServer();
   }
  
   if (server == null) {
      throw new IllegalStateException("No instances available for " + serviceId);
   }

   RibbonLoadBalancerContext context = this.clientFactory.getLoadBalancerContext(serviceId);
   RibbonStatsRecorder statsRecorder = new RibbonStatsRecorder(context, server);

   try {
      // 向 server 实例发起请求的关键步骤
      T returnVal = request.apply(serviceInstance);
      statsRecorder.recordStats(returnVal);
      return returnVal;
   }
   // catch IOException and rethrow so RestTemplate behaves correctly
   catch (IOException ex) {
      statsRecorder.recordStats(ex);
      throw ex;
   }
   catch (Exception ex) {
      statsRecorder.recordStats(ex);
      ReflectionUtils.rethrowRuntimeException(ex);
   }
   return null;
}
```

- 追踪 apply 方法，来到 LoadBalancerRequestFactory.java

```java
public LoadBalancerRequest<ClientHttpResponse> createRequest(final HttpRequest request,final byte[] body, final ClientHttpRequestExecution execution) {
  
   return instance -> {
           HttpRequest serviceRequest = new ServiceRequestWrapper(request, instance, loadBalancer);
           if (transformers != null) {
               for (LoadBalancerRequestTransformer transformer : transformers) {
                   serviceRequest = transformer.transformRequest(serviceRequest, instance);
               }
           }
     
           return execution.execute(serviceRequest, body);
       };
}
```

- 追踪 execute 方法，来到 LoadBalancerRequestFactory.java

```java
ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException;
```

- 追踪execute 方法，来到实现类 InterceptingClientHttpRequest.java

```java
@Override
public ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {
  if (this.iterator.hasNext()) {
    ClientHttpRequestInterceptor nextInterceptor = this.iterator.next();
    return nextInterceptor.intercept(request, body, this);
  }else {
    HttpMethod method = request.getMethod();
    Assert.state(method != null, "No standard HTTP method");
    ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);
    request.getHeaders().forEach((key, value) -> delegate.getHeaders().addAll(key, value));
   
    if (body.length > 0) {
      if (delegate instanceof StreamingHttpOutputMessage) {
        StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate;
        streamingOutputMessage.setBody(outputStream -> StreamUtils.copy(body, outputStream));
      } else {
        StreamUtils.copy(body, delegate.getBody());
      }
    }
    return delegate.execute();
  }
}

```

- 追踪execute 方法，来到 ClientHttpRequest.java

```java
ClientHttpResponse execute() throws IOException;
```

- 追踪execute 方法，来到实现类 AbstractClientHttpRequest.java

```java
@Override
public final ClientHttpResponse execute() throws IOException {
   assertNotExecuted();
   ClientHttpResponse result = executeInternal(this.headers);
   this.executed = true;
   return result;
}
```



#### （8）RibbonAutoConfiguration

```java
@Bean
public SpringClientFactory springClientFactory() {
   SpringClientFactory factory = new SpringClientFactory();
   factory.setConfigurations(this.configurations);
   return factory;
}
```



#### （9）SpringClientFactory.java

```java
public class SpringClientFactory extends NamedContextFactory<RibbonClientSpecification> {
   static final String NAMESPACE = "ribbon";

   public SpringClientFactory() {
      // 在 SpringClientFactory 的构造器中涉及到了 RibbonClientConfiguration
      super(RibbonClientConfiguration.class, NAMESPACE, "ribbon.client.name");
   }
  
  .....
}
```



#### （10）RibbonClientConfiguration.java

```java
@Bean
@ConditionalOnMissingBean
public IRule ribbonRule(IClientConfig config) {
   // 如果配置文件配置了负载策略，则以配置文件为准
   if (this.propertiesFactory.isSet(IRule.class, name)) {
      return this.propertiesFactory.get(IRule.class, config, name);
   }
  
   ZoneAvoidanceRule rule = new ZoneAvoidanceRule();
  
   // 默认返回 ZoneAvoidanceRule 策略
   rule.initWithNiwsConfig(config);
   return rule;
}

....
  
  @Bean
  @ConditionalOnMissingBean
  public ILoadBalancer ribbonLoadBalancer(IClientConfig config,ServerList<Server> serverList, ServerListFilter<Server> serverListFilter,IRule rule, IPing ping, ServerListUpdater serverListUpdater) {
  
  if (this.propertiesFactory.isSet(ILoadBalancer.class, name)) {
    return this.propertiesFactory.get(ILoadBalancer.class, config, name);
  }
  
  // 默认注入的负载均衡器实现为 ZoneAwareLoadBalancer
  // 容器中的 bean 对象 ServerList 被注入到负载均衡器中
  return new ZoneAwareLoadBalancer<>(config, rule, ping, serverList,serverListFilter, serverListUpdater);
}
```

- 根据上面的代码，在进⾏负载 chooseServer 的时候，LoadBalancer负载均衡器中已经有了 serverList，那么这个serverList是什么时候被注⼊到LoadBalancer中的？

```java
// 向容器中注入 bean 对象 ServerList
@Bean
@ConditionalOnMissingBean
@SuppressWarnings("unchecked")
public ServerList<Server> ribbonServerList(IClientConfig config) {
   if (this.propertiesFactory.isSet(ServerList.class, name)) {
      return this.propertiesFactory.get(ServerList.class, config, name);
   }
  
   ConfigurationBasedServerList serverList = new ConfigurationBasedServerList();
   serverList.initWithNiwsConfig(config);
   return serverList;
}
```

- 追踪 ZoneAwareLoadBalancer（ZoneAwareLoadBalancer.java）

```java
public ZoneAwareLoadBalancer(IClientConfig clientConfig, 
                             IRule rule,
                             IPing ping, 
                             ServerList<T> serverList, 
                             ServerListFilter<T> filter,
                             ServerListUpdater serverListUpdater) {
  
    super(clientConfig, rule, ping, serverList, filter, serverListUpdater);
}
```

- 追踪父类 DynamicServerListLoadBalancer.java

```java
public DynamicServerListLoadBalancer(IClientConfig clientConfig, 
																		 IRule rule, 
																		 IPing ping,
                                     ServerList<T> serverList, 
                                     ServerListFilter<T> filter,
                                     ServerListUpdater serverListUpdater) {
                                     
    super(clientConfig, rule, ping);
    this.serverListImpl = serverList;
    this.filter = filter;
    this.serverListUpdater = serverListUpdater;
    
    if (filter instanceof AbstractServerListFilter) {
        ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());
    }
    
    restOfInit(clientConfig);
}
```

- 追踪 restOfInit 方法

```java
void restOfInit(IClientConfig clientConfig) {
    boolean primeConnection = this.isEnablePrimingConnections();
    // turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()
    this.setEnablePrimingConnections(false);
    
    // 该方法会开启一个延时定时任务，若干时间后每隔一定时间，就去 Eureka Client 缓存中获取新的服务实例信息
    // Eureka Client 也会定时从 Eureka Sever 更新服务信息，然后更新到 Ribbon 本地缓存中
  	enableAndInitLearnNewServersFeature();

    // 因为上面定义了延时定时任务，并没有马上执行，这里执行更新
    updateListOfServers();
  
    if (primeConnection && this.getPrimeConnections() != null) {
        this.getPrimeConnections().primeConnections(getReachableServers());
    }
  
    this.setEnablePrimingConnections(primeConnection);
    LOGGER.info("DynamicServerListLoadBalancer for client {} initialized: {}", clientConfig.getClientName(), this.toString());
}
```

- 追踪 enableAndInitLearnNewServersFeature 方法

```java
public void enableAndInitLearnNewServersFeature() {
    LOGGER.info("Using serverListUpdater {}", serverListUpdater.getClass().getSimpleName());
    serverListUpdater.start(updateAction);
}
```

- 追踪 updateAction

```java
protected final ServerListUpdater.UpdateAction updateAction = new ServerListUpdater.UpdateAction() {
    @Override
    public void doUpdate() {
        updateListOfServers();
    }
};
```

- 追踪 updateListOfServers 方法

```java
@VisibleForTesting
public void updateListOfServers() {
    List<T> servers = new ArrayList<T>();
    if (serverListImpl != null) {
        servers = serverListImpl.getUpdatedListOfServers();
        LOGGER.debug("List of Servers for {} obtained from Discovery client: {}",getIdentifier(), servers);

        if (filter != null) {
            servers = filter.getFilteredListOfServers(servers);
            LOGGER.debug("Filtered List of Servers for {} obtained from Discovery client: {}",getIdentifier(), servers);
        }
    }
    updateAllServerList(servers);
}
```

- 追踪 start 方法，来到 PollingServerListUpdater.java

```java
@Override
public synchronized void start(final UpdateAction updateAction) {
    if (isActive.compareAndSet(false, true)) {
        // 定义了线程
        final Runnable wrapperRunnable = new Runnable() {
            @Override
            public void run() {
                if (!isActive.get()) {
                    if (scheduledFuture != null) {
                        scheduledFuture.cancel(true);
                    }
                    return;
                }
                try {
                    // 调用传进来的 updateAction 中的 doUpdate 方法
                    updateAction.doUpdate();
                    lastUpdated = System.currentTimeMillis();
                } catch (Exception e) {
                    logger.warn("Failed one update cycle", e);
                }
            }
        };

        // 定义了延迟定时任务，定时更新服务信息
        scheduledFuture = getRefreshExecutor().scheduleWithFixedDelay(
                wrapperRunnable,
                initialDelayMs,
                refreshIntervalMs,
                TimeUnit.MILLISECONDS
        );
    } else {
        logger.info("Already active, no-op");
    }
}
```



### 5.2 源码分析 - 负载均衡策略（RoundRobinRule.java）

- com/netflix/loadbalancer/RoundRobinRule.java

```java
public Server choose(ILoadBalancer lb, Object key) {
    if (lb == null) {
        log.warn("no load balancer");
        return null;
    }

    Server server = null;
    int count = 0;
  
    while (server == null && count++ < 10) {
        // 可⽤服务实例列表
        List<Server> reachableServers = lb.getReachableServers();
      
        // 所有服务实例列表
        List<Server> allServers = lb.getAllServers();
      
        int upCount = reachableServers.size();
        int serverCount = allServers.size();

        if ((upCount == 0) || (serverCount == 0)) {
            log.warn("No up servers available from load balancer: " + lb);
            return null;
        }

        // 获得⼀个轮询索引（根据服务器实例数量获取一个随机数，并根据随机数取出服务实例）
        int nextServerIndex = incrementAndGetModulo(serverCount);
      
        // 根据索引取出服务实例对象
        server = allServers.get(nextServerIndex);

        if (server == null) {
            /* Transient. */
            Thread.yield();
            continue;
        }

        // 判断服务实例状态是否为 up，可⽤就返回
        if (server.isAlive() && (server.isReadyToServe())) {
            return (server);
        }

        // Next.
        server = null;
    }

    if (count >= 10) {
        log.warn("No available alive servers after 10 tries from load balancer: "
                + lb);
    }
    return server;
}
```



# 第三章 服务熔断 - Netflix Hystrix

## 1、微服务中的雪崩效应

### 1.1 雪崩效应 - 概述

- 扇⼊：代表上游微服务对该微服务被调用次数，扇入大，说明该模块复用性好
- 扇出：代表该微服务对下游微服务的调用次数，扇出⼤，说明业务逻辑复杂

- 在微服务架构中，⼀个应⽤可能会有多个微服务组成，微服务之间的数据交互通过远程过程调⽤完成。这就带来⼀个问题，假设微服务A调⽤微服务B和微服务C，微服务B和微服务C⼜调⽤其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调⽤响应时间过⻓或者不可⽤，对微服务A的调⽤就会占⽤越来越多的系统资源，进⽽引起系统崩溃，所谓的“雪崩效应”。



### 1.2 雪崩效应 - 解决方案

- 从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术⼿段

#### （1）服务熔断

- 熔断机制是应对雪崩效应的⼀种微服务链路保护机制。
- 当扇出链路的某个微服务不可⽤或者响应时间太⻓时，熔断该节点微服务的调⽤，进⾏服务的降级，快速返回错误的响应信息。当检测到该节点微服务调⽤响应正常后，恢复调⽤链路。

```
- 服务熔断重点在“断”，切断对下游服务的调⽤
- 服务熔断和服务降级往往是⼀起使⽤的，Hystrix就是这样。
```



#### （2）服务降级

- 通俗讲就是整体资源不够⽤了，先将⼀些不关紧的服务停掉（调⽤的时候，返回⼀个预留的值，也叫做兜底数据），待渡过难关⾼峰过去，再把那些服务打开。
- 服务降级⼀般是从整体考虑，就是当某个服务熔断之后，服务器将不再被调⽤，此刻客户端可以⾃⼰准备⼀个本地的fallback回调，返回⼀个缺省值



#### （3）服务限流

- 服务降级是当服务出问题或者影响到核⼼流程的性能时，暂时将服务屏蔽掉，待⾼峰或者问题解决后再打开
- 但是有些场景并不能⽤服务降级来解决，⽐如秒杀业务这样的核⼼功能，这个时候可以结合服务限流来限制这些场景的并发/请求量
- 限流措施

```
- 限制总并发数（⽐如数据库连接池、线程池）
- 限制瞬时并发数（如nginx限制瞬时并发连接数）
- 限制时间窗⼝内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）
- 限制远程接⼝调⽤速率、限制MQ的消费速率等
```



## 2、Hystrix 简介

- Hystrix 是由Netflix开源的⼀个延迟和容错库
- ⽤于隔离访问远程系统、服务或者第三⽅库，防⽌级联失败，从⽽提升系统的可⽤性与容错性
- Hystrix 主要通过以下⼏点实现延迟和容错

```
包裹请求
- 使⽤ @HystrixCommand 注解，包裹对依赖的调⽤逻辑

跳闸机制
- 当某服务的错误率超过⼀定的阈值时，Hystrix可以跳闸，停⽌请求该服务⼀段时间。

回退机制
- 当请求失败、超时、被拒绝，或当断路器打开时，执⾏回退逻辑。
- 回退逻辑由开发⼈员⾃⾏提供，例如返回⼀个缺省值。

资源隔离（舱壁模式）
- Hystrix 为每个依赖都维护了⼀个⼩型的线程池（舱壁模式）或者信号量
- 如果该线程池已满， 发往该依赖的请求就被⽴即拒绝，⽽不是排队等待，从⽽加速失败判定。

自我修复
- 断路器打开⼀段时间后，会⾃动进⼊“半开”状态

监控
- Hystrix 可以近乎实时地监控运⾏指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。
```



## 3、Hystrix 使用

### 3.0 依赖包

```xml
<!-- 熔断器 Hystrix -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>
```



### 3.1 包裹请求（注解写在启动类上）

#### 方式1：开启 Hystrix 功能

```java
@EnableHystrix
```

#### 方式2：开启熔断器功能（通用）

```java
@EnableCircuitBreaker
```

#### 方式3：综合性的注解

```java
// @SpringCloudApplication  = @SpringBootApplication + @EnableDiscoveryClient + @EnableCircuitBreaker
@SpringCloudApplication
```



### 3.2 跳闸机制

- 使用 @HystrixCommand 注解进行熔断控制
- 使用 execution.isolation.thread.timeoutInMilliseconds 进行超时时间设置

```java
@HystrixCommand(
        // 熔断的一些细节属性配置
        commandProperties = {
                // 每一个属性都是一个 HystrixProperty
                @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "2000")
        }
)
@GetMapping("/checkState4/{userId}")
public Integer findResumeOpenState4(@PathVariable Long userId) {
    // 指定服务名
    String url = "http://resume-service-resume/resume/openstate/" + userId;
    Integer forObject = restTemplate.getForObject(url, Integer.class);
    return forObject;
}
```



### 3.3 回退机制（熔断后回退，返回预设默认值）

- 使用 fallbackMethod，返回预设默认值（即兜底数据）
- 降级（兜底）方法必须和被降级⽅法相同的⽅法签名（相同参数列表、相同返回值）
- 可以在类上使用 @DefaultProperties 注解统⼀指定整个类中共⽤的降级（兜底）方法

```java
@HystrixCommand(
        // 熔断的一些细节属性配置
        commandProperties = {
                // 每一个属性都是一个 HystrixProperty
                @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "2000"),
        },
        fallbackMethod = "myFallBack"  // 回退方法
)
@GetMapping("/checkState5/{userId}")
public Integer findResumeOpenState5(@PathVariable Long userId) {
    // 指定服务名
    String url = "http://resume-service-resume/resume/openstate/" + userId;
    Integer forObject = restTemplate.getForObject(url, Integer.class);
    return forObject;
}

/**
 * 定义回退方法，返回预设默认值（该方法形参和返回值与原始方法保持一致）
 */
public Integer myFallBack(Long userId) {
  return -123333; // 兜底数据
}
```



### 3.4 舱壁模式（线程池隔离策略）

- 如果不进⾏任何设置，所有熔断⽅法使⽤⼀个 Hystrix 线程池（假设默认为10个线程），那么会导致问题，这个问题并不是扇出链路微服务不可⽤导致的，⽽是线程机制导致的，
- 如果⽅法A的请求把10个线程都⽤了，⽅法2请求处理的时候压根都没法去访问B，因为没有线程可⽤，并不是B服务不可⽤。
- 为了避免问题服务请求过多导致正常服务⽆法访问，Hystrix 不是采⽤增加线程数，⽽是单独的为每⼀个控制⽅法创建⼀个线程池的⽅式，这种模式叫做”舱壁模式“，也是线程隔离的⼿段。

```java
@HystrixCommand(
        // 线程池标识，要保持唯一，不唯一的话就共用了
        threadPoolKey = "findResumeOpenState6",

        // 线程池细节属性配置
        threadPoolProperties = {
                @HystrixProperty(name = "coreSize", value = "2"), // 线程数
                @HystrixProperty(name = "maxQueueSize", value = "20") // 等待队列长度
        },

        // 熔断的一些细节属性配置
        commandProperties = {
                // 每一个属性都是一个 HystrixProperty
                @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "2000")
        },
        fallbackMethod = "myFallBack"  // 回退方法
)
@GetMapping("/checkState6/{userId}")
public Integer findResumeOpenState6(@PathVariable Long userId) {
    // 指定服务名
    String url = "http://resume-service-resume/resume/openstate/" + userId;
    Integer forObject = restTemplate.getForObject(url, Integer.class);
    return forObject;
}
```



### 3.5 熔断策略（跳闸后自我修复）

![image-20211110170906840](image/image-20211110170906840.png)

#### （1）跳闸后自我修复步骤

```
步骤1：当调⽤出现问题时，开启⼀个时间窗（10s）

步骤2：在这个时间窗内，统计调⽤次数是否达到最⼩请求数？
- 如果没有达到，则重置统计信息，回到第1步
- 如果达到了，则统计失败的请求数占所有请求数的百分⽐，是否达到阈值？
- 如果达到，则跳闸（不再请求对应服务）
- 如果没有达到，则重置统计信息，回到第1步

步骤3：
- 如果跳闸，则会开启⼀个活动窗⼝（默认5s）
- 每隔5s，Hystrix会让⼀个请求通过,到达那个问题服务，看是否调⽤成功
- 如果成功，重置断路器回到第1步
- 如果失败，回到第3步
```

#### （2）代码使用

- 注解式作用范围：在某一方法上
- 配置式作用范围：全局
- 当注解式 和 配置式 同时使用，注解式配置优先生效

##### 方式1：注解式

```java
@HystrixCommand(
        // 线程池标识，要保持唯一，不唯一的话就共用了
        threadPoolKey = "findResumeOpenState7",

        // 线程池细节属性配置
        threadPoolProperties = {
                @HystrixProperty(name = "coreSize", value = "2"), // 线程数
                @HystrixProperty(name = "maxQueueSize", value = "20") // 等待队列长度
        },

        // 熔断的一些细节属性配置
        commandProperties = {
                // 每一个属性都是一个 HystrixProperty
                @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "2000"),

                // Hystrix 熔断策略（高级配置，定制工作过程细节）
                // 8秒钟内，请求次数达到2个，并且失败率在50%以上，就跳闸，跳闸后活动窗⼝设置为3s
                // 统计时间窗口定义
                @HystrixProperty(name = "metrics.rollingStats.timeInMilliseconds", value = "8000"),
                // 统计时间窗口内的最小请求数
                @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "2"),
                // 统计时间窗口内的错误数量百分比阈值
                @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),
                // 自我修复时的活动窗口长度
                @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "3000")
        },
        fallbackMethod = "myFallBack"  // 回退方法
)
@GetMapping("/checkState7/{userId}")
public Integer findResumeOpenState7(@PathVariable Long userId) {
    // 指定服务名
    String url = "http://resume-service-resume/resume/openstate/" + userId;
    Integer forObject = restTemplate.getForObject(url, Integer.class);
    return forObject;
}
```



##### 方式2：配置式（application.yml）

```yaml
# 配置熔断策略
hystrix:
 command:
 default:
 circuitBreaker:
 # 强制打开熔断器，如果该属性设置为true，强制断路器进⼊打开状态，将会拒绝所有的请求。 默认false关闭的
 forceOpen: false
 # 触发熔断错误比例阈值，默认值50%
 errorThresholdPercentage: 50
 # 熔断后休眠时长，默认值5秒
 sleepWindowInMilliseconds: 3000 
 # 熔断触发最小请求次数，默认值是20
 requestVolumeThreshold: 2 
 execution:
 isolation:
 thread:
 # 熔断超时设置，默认为1秒
 timeoutInMilliseconds: 2000
```



#### （3）查看跳闸状态变化

- 配合 SpringBoot 监控检查接口（http://localhost:8081/actuator/health）

```yaml
# springboot 中暴露健康检查等断点接口
management:
  endpoints:
    web:
      exposure:
        include: "*"
  # 暴露健康接口的细节
  endpoint:
    health:
      show-details: always
```

- 状态变化

```json
// 未跳闸
"hystrix": {
  "status": "UP"
}

// 跳闸
"hystrix": {
  "status": "CIRCUIT_OPEN",
  "details": {
    "openCircuitBreakers": [
      "AutodeliverController::findResumeOpenState7"
    ]
  }
}

// 自我修复后
"hystrix": {
  "status": "UP"
}
```



## 4、Hystrix 监控

### 4.1 Hystrix Dashboard（断路监控仪表盘）

#### （1）简介

- Hystrix Dashboard 仪表板可以显示每个断路器（被 @HystrixCommand 注解的⽅法）的状态

![image-20211110183901120](image/image-20211110183901120.png)

#### （2）使用

##### 步骤1：导入依赖

- 父工程引入 SpringBoot的 actuator（健康监控）

```xml
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

- 子工程 Dashboard

```xml
<dependencies>
    <!-- hystrix -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    </dependency>

    <!-- hystrix 仪表盘 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    </dependency>

    <!-- eureka-client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
</dependencies>
```



##### 步骤2：启动类添加 @EnableHystrixDashboard 激活仪表盘 

```java
@SpringBootApplication
@EnableDiscoveryClient
// 开启 hystrix dashboard
@EnableHystrixDashboard
public class HystrixDashboard9000 {
    public static void main(String[] args) {
        SpringApplication.run(HystrixDashboard9000.class, args);
    }
}
```



##### 步骤3：yml 配置

```yaml
server:
  port: 9000

Spring:
  application:
    name: cloud-hystrix-dashboard

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



##### 步骤4：在被监测的微服务启动类中注册监控 servlet

- 前提：被监控的微服务需要引入 springboo t的 actuator 功能

```java
@Bean
public ServletRegistrationBean getServlet() {
  HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
  ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
  registrationBean.setLoadOnStartup(1);
  registrationBean.addUrlMappings("/actuator/hystrix.stream");
  registrationBean.setName("HystrixMetricsStreamServlet");
  return registrationBean;
}
```



##### 步骤5：访问

- 直接访问监控 servlet：http://localhost:8090/actuator/hystrix.stream
- 访问 Hystrix Dashboard（断路监控仪表盘）：http://localhost:9000/hystrix

![image-20211110183703566](image/image-20211110183703566.png)

##### 步骤6：界面

- 百分比，表示 10s 内错误请求百分比

![image-20211110183344463](image/image-20211110183344463.png)



- 实⼼圆⼤⼩：代表请求流量的⼤⼩，流量越⼤球越⼤
- 实⼼圆颜⾊：代表请求处理的健康状态，从绿⾊到红⾊递减，绿⾊代表健康，红⾊就代表很不健康
- 曲线波动图：记录了2分钟内该⽅法上流量的变化波动图，判断流量上升或者下降的趋势

![image-20211110183455440](image/image-20211110183455440.png)



### 4.2 Hystrix Turbine（聚合监控）

#### （1）简介

- 使⽤ Hystrix Turbine 进⾏聚合监控，它可以把相关微服务的监控数据聚合在⼀起，便于查看

![image-20211110184028093](image/image-20211110184028093.png)



#### （2）使用

##### 步骤1：导入依赖

- 父工程引入 SpringBoot的 actuator（健康监控）

```xml
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

- 子工程 Dashboard

```xml
<dependencies>
  <!--hystrix turbine 聚合监控-->
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-turbine</artifactId>
  </dependency>

  <!-- eureka client -->
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
  </dependency>
</dependencies>
```



##### 步骤2：启动类添加 @EnableTurbine 开启聚合功能

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableTurbine  // 开启 Turbine 聚合功能
public class HystrixTurbineApplication9001 {
    public static void main(String[] args) {
        SpringApplication.run(HystrixTurbineApplication9001.class, args);
    }
}
```



##### 步骤3：yml 配置

```yaml
server:
  port: 9001

Spring:
  application:
    name: cloud-hystrix-turbine

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@

# Turbine 配置
turbine:
  # 配置需要聚合的服务名称，如果要聚合多个微服务的监控数据，那么可以使用英文逗号拼接，比如 a,b,c
  appConfig: resume-service-autodeliver
  # 集群默认名称
  clusterNameExpression: "'default'"
```



##### 步骤4：启动

- 按顺序启动下面8个服务

![image-20211110191807193](image/image-20211110191807193.png)



##### 步骤5：访问

- 直接访问 Turbine：http://localhost:9001/turbine.stream
- 访问 Hystrix Dashboard（断路监控仪表盘）：http://localhost:9000/hystrix

![image-20211110192549943](image/image-20211110192549943.png)





## 5、Hystrix 源码分析

### 5.1 入口：@EnableCircuitBreaker 注解

- EnableCircuitBreaker.java

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
// 导入了一个 Selector
@Import(EnableCircuitBreakerImportSelector.class)
public @interface EnableCircuitBreaker {

}
```



### 5.2 EnableCircuitBreakerImportSelector.java

- EnableCircuitBreakerImportSelector.java

```java
@Order(Ordered.LOWEST_PRECEDENCE - 100)
// 父类 SpringFactoryImportSelector 的泛型传入注解类 EnableCircuitBreaker
public class EnableCircuitBreakerImportSelector extends SpringFactoryImportSelector<EnableCircuitBreaker> {
   // 获取断路器开关配置
   @Override
   protected boolean isEnabled() {
      return getEnvironment().getProperty("spring.cloud.circuit.breaker.enabled", Boolean.class, Boolean.TRUE);
   }
}
```



### 5.3 SpringFactoryImportSelector.java

- EnableCircuitBreakerImportSelector.java 的父类

```java
// 构造器
protected SpringFactoryImportSelector() {
   // 获取到子类传递到父类的泛型（即 EnableCircuitBreaker 注解类）
   this.annotationClass = (Class<T>) GenericTypeResolver.resolveTypeArgument(this.getClass(), SpringFactoryImportSelector.class);
}
```

- 关注 selectImports 方法

```java
@Override
public String[] selectImports(AnnotationMetadata metadata) {
   if (!isEnabled()) {
      return new String[0];
   }
  
   // 根据传进来的泛型全限定类名作为 key 去 spring.factories 文件查找对应的配置类，然后注入
   // 这里查到的结果是：org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration
   AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(this.annotationClass.getName(), true));

   Assert.notNull(attributes, "No " + getSimpleName() + " attributes found. Is "+ metadata.getClassName() + " annotated with @" + getSimpleName() + "?");

   // Find all possible auto configuration classes, filtering duplicates
   List<String> factories = new ArrayList<>(new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(this.annotationClass, this.beanClassLoader)));

   if (factories.isEmpty() && !hasDefaultFactory()) {
      throw new IllegalStateException("Annotation @" + getSimpleName() + " found, but there are no implementations. Did you forget to include a starter?");
   }

   if (factories.size() > 1) {
      // there should only ever be one DiscoveryClient, but there might be more than
      // one factory
      log.warn("More than one implementation " + "of @" + getSimpleName() + " (now relying on @Conditionals to pick one): " + factories);
   }

   return factories.toArray(new String[factories.size()]);
}
```

- 查到的结果如下

```properties
org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\
org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration
```

- 关注 org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration.java

```java
@Configuration
public class HystrixCircuitBreakerConfiguration {
   // 注入了 HystrixCommandAspect 切面
   @Bean
   public HystrixCommandAspect hystrixCommandAspect() {
      return new HystrixCommandAspect();
   }
  
  .....   
}
```



### 5.4 HystrixCommandAspect.java

```java
// 切入点
@Pointcut("@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand)")
public void hystrixCommandAnnotationPointcut() {
}

// 切入点
@Pointcut("@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)")
public void hystrixCollapserAnnotationPointcut() {
}

// 环绕通知
@Around("hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()")
public Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint joinPoint) throws Throwable {
    .....
}
```

- 关注 methodsAnnotatedWithHystrixCommand 方法，环绕通知

```java
static {
  META_HOLDER_FACTORY_MAP = ImmutableMap.<HystrixPointcutType, MetaHolderFactory>builder()
    .put(HystrixPointcutType.COMMAND, new CommandMetaHolderFactory())
    .put(HystrixPointcutType.COLLAPSER, new CollapserMetaHolderFactory())
    .build();
}

@Around("hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()")
public Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint joinPoint) throws Throwable {
    // 获取原始目标方法
    Method method = getMethodFromTarget(joinPoint);
  
    Validate.notNull(method, "failed to get method from joinPoint: %s", joinPoint);
  
    if (method.isAnnotationPresent(HystrixCommand.class) && method.isAnnotationPresent(HystrixCollapser.class)) {
        throw new IllegalStateException("method cannot be annotated with HystrixCommand and HystrixCollapser " +"annotations at the same time");
    }
  
    MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));
  
    // 获取封装元数据
    MetaHolder metaHolder = metaHolderFactory.create(joinPoint);
  
    // 创建可执行器 HystrixInvokable 对象，本质是 GenericCommand 对象
    HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder);
  
    // 获取执行方法（同步 或者 异步 或者 observable）
    ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ? metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType();

    Object result;
    try {
        // 非 observable 类型
        if (!metaHolder.isObservable()) {
            result = CommandExecutor.execute(invokable, executionType, metaHolder);
        } else {
            result = executeObservable(invokable, executionType, metaHolder);
        }
    } catch (HystrixBadRequestException e) {
        throw e.getCause();
    } catch (HystrixRuntimeException e) {
        throw hystrixRuntimeExceptionToThrowable(metaHolder, e);
    }
    return result;
}
```



#### （1）关注 create 方法

- HystrixCommandFactory.getInstance().create(metaHolder)

- 跳转到 HystrixCommandFactory.java

```java
public HystrixInvokable create(MetaHolder metaHolder) {
    HystrixInvokable executable;
    if (metaHolder.isCollapserAnnotationPresent()) {
        executable = new CommandCollapser(metaHolder);
    } else if (metaHolder.isObservable()) {
        executable = new GenericObservableCommand(HystrixCommandBuilderFactory.getInstance().create(metaHolder));
    } else {
        // GenericCommand 中根据元数据信息重写了两个核心方法
        // ⼀个是run⽅法封装了对原始⽬标⽅法的调⽤，另外⼀个是getFallBack⽅法它封装了对回退⽅法的调⽤
        // 在 GenericCommand 的上层类构造函数中会完成资源的初始化
        // ⽐如线程池 GenericCommand —> AbstractHystrixCommand —> HystrixCommand -> AbstractCommand
        executable = new GenericCommand(HystrixCommandBuilderFactory.getInstance().create(metaHolder));
    }
    return executable;
}
```

- 关注 AbstractCommand.java

```java
protected AbstractCommand(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults, HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore, HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook) {

    // 资源初始化
    this.commandGroup = initGroupKey(group);
    this.commandKey = initCommandKey(key, getClass());
    this.properties = initCommandProperties(this.commandKey, propertiesStrategy, commandPropertiesDefaults);
    this.threadPoolKey = initThreadPoolKey(threadPoolKey, this.commandGroup, this.properties.executionIsolationThreadPoolKeyOverride().get());
    this.metrics = initMetrics(metrics, this.commandGroup, this.threadPoolKey, this.commandKey, this.properties);
    this.circuitBreaker = initCircuitBreaker(this.properties.circuitBreakerEnabled().get(), circuitBreaker, this.commandGroup, this.commandKey, this.properties, this.metrics);
    // 线程池
    this.threadPool = initThreadPool(threadPool, this.threadPoolKey, threadPoolPropertiesDefaults);

    //Strategies from plugins
    this.eventNotifier = HystrixPlugins.getInstance().getEventNotifier();
    this.concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();
    HystrixMetricsPublisherFactory.createOrRetrievePublisherForCommand(this.commandKey, this.commandGroup, this.metrics, this.circuitBreaker, this.properties);
    this.executionHook = initExecutionHook(executionHook);

    this.requestCache = HystrixRequestCache.getInstance(this.commandKey, this.concurrencyStrategy);
    this.currentRequestLog = initRequestLog(this.properties.requestLogEnabled().get(), this.concurrencyStrategy);

    /* fallback semaphore override if applicable */
    this.fallbackSemaphoreOverride = fallbackSemaphore;

    /* execution semaphore override if applicable */
    this.executionSemaphoreOverride = executionSemaphore;
}
```

- 关注  initThreadPool 方法

```java
private static HystrixThreadPool initThreadPool(HystrixThreadPool fromConstructor, HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults) {
    if (fromConstructor == null) {
        // get the default implementation of HystrixThreadPool
        return HystrixThreadPool.Factory.getInstance(threadPoolKey, threadPoolPropertiesDefaults);
    } else {
        return fromConstructor;
    }
}
```

- 关注 getInstance 方法
- 跳转到 HystrixThreadPool.java

```java
/* package */static HystrixThreadPool getInstance(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder) {
    // get the key to use instead of using the object itself so that if people forget to implement equals/hashcode things will still work
    String key = threadPoolKey.name();

    // this should find it for all but the first time
    // threadPools 本质是 ConcurrentHashMap，使用了 ConcurrentHashMap 对线程池进行缓存
    HystrixThreadPool previouslyCached = threadPools.get(key);
    if (previouslyCached != null) {
        return previouslyCached;
    }

    // if we get here this is the first time so we need to initialize
    synchronized (HystrixThreadPool.class) {
        if (!threadPools.containsKey(key)) {
            // 缓存中没有，则创建
            threadPools.put(key, new HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));
        }
    }
    return threadPools.get(key);
}
```

- 关注 HystrixThreadPoolDefault

```java
public HystrixThreadPoolDefault(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesDefaults) {
    this.properties = HystrixPropertiesFactory.getThreadPoolProperties(threadPoolKey, propertiesDefaults);
    HystrixConcurrencyStrategy concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();
    this.queueSize = properties.maxQueueSize().get();

    this.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,concurrencyStrategy.getThreadPool(threadPoolKey, properties),properties);
  
    this.threadPool = this.metrics.getThreadPool();
    this.queue = this.threadPool.getQueue();

    /* strategy: HystrixMetricsPublisherThreadPool */
    HystrixMetricsPublisherFactory.createOrRetrievePublisherForThreadPool(threadPoolKey, this.metrics, this.properties);
}
```

- 关注 getThreadPool 方法
- 跳转到 HystrixConcurrencyStrategy.java

```java
public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties) {
    final ThreadFactory threadFactory = getThreadFactory(threadPoolKey);

    final boolean allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();
    final int dynamicCoreSize = threadPoolProperties.coreSize().get();
    final int keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();
    final int maxQueueSize = threadPoolProperties.maxQueueSize().get();
    final BlockingQueue<Runnable> workQueue = getBlockingQueue(maxQueueSize);

    if (allowMaximumSizeToDivergeFromCoreSize) {
        final int dynamicMaximumSize = threadPoolProperties.maximumSize().get();
        if (dynamicCoreSize > dynamicMaximumSize) {
            logger.error("Hystrix ThreadPool configuration at startup for : " + threadPoolKey.name() + " is trying to set coreSize = " + dynamicCoreSize + " and maximumSize = " + dynamicMaximumSize + ".  Maximum size will be set to " +dynamicCoreSize + ", the coreSize value, since it must be equal to or greater than the coreSize value");
            
            // 最终是根据属性创建了 ThreadPoolExecutor
            return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
        } else {
            return new ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
        }
    } else {
        return new ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
    }
}
```



#### （2）关注 execute 方法

- 跳转到 CommandExecutor.java

```java
public static Object execute(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {
    Validate.notNull(invokable);
    Validate.notNull(metaHolder);

    switch (executionType) {
        // 同步的执行类型
        case SYNCHRONOUS: {
            return castToExecutable(invokable, executionType).execute();
        }
        
        case ASYNCHRONOUS: {
            HystrixExecutable executable = castToExecutable(invokable, executionType);
            if (metaHolder.hasFallbackMethodCommand()
                    && ExecutionType.ASYNCHRONOUS == metaHolder.getFallbackExecutionType()) {
                return new FutureDecorator(executable.queue());
            }
            return executable.queue();
        }
        
        case OBSERVABLE: {
            HystrixObservable observable = castToObservable(invokable);
            return ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ? observable.observe() : observable.toObservable();
        }
        
        default:
            throw new RuntimeException("unsupported execution type: " + executionType);
    }
}
```

- 关注 execute 方法
- 跳转到 HystrixExecutable.java

```java
public R execute();
```

- 跳转到实现类 HystrixCommand.java

```java
public R execute() {
    try {
        // queue 方法会返回 Feture 对象（封装异步处理的结果）
        return queue().get();
    } catch (Exception e) {
        throw Exceptions.sneakyThrow(decomposeException(e));
    }
}
```

- 关注 queue() 方法

```java
public Future<R> queue() {
    // Future 的获取，业务逻辑执行，异常后对回退方法的调用等，都使用了 RxJava 响应式编程
    final Future<R> delegate = toObservable().toBlocking().toFuture();
   
    final Future<R> f = new Future<R>() {
      .....
    }
}
```



# 第四章 远程服务调用 - Netflix Feign

## 1、Feign 简介

- Feign 是 Netflix 开发的⼀个轻量级 RESTful 的 HTTP 服务客户端（⽤它来发起请求，远程调⽤的）
- Feign 是以 Java 接⼝注解的⽅式调⽤ Http 请求，⽽不⽤像Java中通过封装 HTTP 请求报⽂的⽅式直接调⽤
- 本质：封装了Http调⽤流程，更符合⾯向接⼝化的编程习惯，类似于Dubbo的服务调⽤



## 2、Feign 使用

- （效果）Feign = RestTemplate + Ribbon + Hystrix



### 步骤1：引入 Feign 依赖 

```xml
<!-- Feign 依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```



### 步骤2：application.yml

```yaml
server:
  port: 8092

spring:
  application:
    name: resume-service-autodeliver

# springboot 中暴露健康检查等断点接口
management:
  endpoints:
    web:
      exposure:
        include: "*"
  # 暴露健康接口的细节
  endpoint:
    health:
      show-details: always

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@

# 针对的被调用方微服务名称 resume-service-resume（不加 33 行这个服务名称，就是全局生效）
resume-service-resume:
  ribbon:
    # 负载策略调整：使用轮询
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
```



### 步骤3：启动类添加 @EnableFeignClients

- 此时去掉 Hystrix 熔断的⽀持注解 @EnableCircuitBreaker ，包括引⼊的依赖，因为 Feign 会⾃动引⼊

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients  // 开启 Feign 客户端功能
public class AutodeliverApplication8092 {
    public static void main(String[] args) {
        SpringApplication.run(AutodeliverApplication8092.class, args);
    }
}
```



### 步骤4：创建 Feign 接口（ResumeServiceFeignClient）

```java
// @FeignClient：表明当前类是一个 Feign 客户端
// value：指定该客户端要请求的服务名称（登记到注册中心上的服务提供者的服务名称）
// fallback：回退实现类
// path：当使用 fallback 时，无法使用 @RequestMapping("/resume")，而需要使用 path
@FeignClient(value = "resume-service-resume", fallback = ResumeFallback.class, path = "/resume")
public interface ResumeServiceFeignClient {
    // Feign 作用：拼装 url，发起请求
    // 调用该方法就是调用本地接口方法，实际上做的是远程请求
    @GetMapping("/openstate/{userId}")
    public Integer findDefaultResumeState(@PathVariable("userId") Long userId);
}
```



### 步骤5：降级回退逻辑，实现 FeignClient 接口，实现接口中的方法

- 针对超时这⼀点，当前有两个超时时间设置（Feign/hystrix）
- 熔断的时候是根据这两个时间的最⼩值来进⾏的，即处理时⻓超过最短的那个超时时间，就熔断进⼊回退降级逻辑

```java
@Component
public class ResumeFallback implements ResumeServiceFeignClient {
    @Override
    public Integer findDefaultResumeState(Long userId) {
        return -1;
    }
}
```



### 步骤6：在接口方法中完成远程调用（AutodeliverController）

```java
@RestController
@RequestMapping("/autodeliver")
public class AutodeliverController {
    @Autowired
    private ResumeServiceFeignClient resumeServiceFeignClient;

    //http://localhost:8092/autodeliver/checkState/1545132
    @GetMapping("/checkState/{userId}")
    public Integer findResumeOpenState(@PathVariable Long userId) {
        Integer defaultResumeState = resumeServiceFeignClient.findDefaultResumeState(userId);
        return defaultResumeState;
    }
}
```



## 3、Feign 对负载均衡 Ribbon 的支持

- Feign 本身已经集成了 Ribbon 依赖和⾃动配置，因此不需要额外引⼊依赖
- 可以通过 ribbon.xx 来进 ⾏全局配置，也可以通过服务名.ribbon.xx 来对指定服务进⾏细节配置配置
- Feign默认的请求处理超时时⻓1s，有时候业务确实执⾏的需要⼀定时间，那么这个时候，就需要调整请求处理超时时⻓，Feign⾃⼰有超时设置，如果配置Ribbon的超时，则会以Ribbon的为准

```yaml
# 针对的被调用方微服务名称 resume-service-resume（不加这个服务名称，就是全局生效）
resume-service-resume:
  ribbon:
    # 负载策略调整：使用轮询
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    ###############################  以下是 Feign 对负载均衡 Ribbon 的支持 ###############################
    # 请求连接超时时间
    ConnectTimeout: 2000
    # 请求处理超时时间（Feign 超时时长设置）
    ReadTimeout: 5000
    # 对所有操作都进行重试
    OkToRetryOnAllOperations: true
    #### 根据如上配置，当访问到故障请求的时候，它会再尝试访问一次当前实例（次数由 MaxAutoRetries 配置）
    #### 如果不行，就换一个实例进行访问，如果还不行，再换一次实例访问（更换次数由 MaxAutoRetriesNextServer 配置）
    #### 如果依然不行，返回失败信息
    MaxAutoRetries: 0             # 对当前选中实例重试次数，不包括第一次调用
    MaxAutoRetriesNextServer: 0   # 切换实例的重试次数
```



## 4、Feign 对熔断器 Hystrix 的支持

```yaml
# Feign 对熔断器 Hystrix 的支持
feign:
  hystrix:
    # 开启 Feign 的熔断功能
    enabled: true

hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            # Hystrix 超时时长设置
            timeoutInMilliseconds: 15000
```



## 5、Feign 对请求压缩和响应压缩的支持

- Feign ⽀持对请求和响应进⾏GZIP压缩，以减少通信过程中的性能损耗。

```yaml
# Feign 对请求压缩和响应压缩的支持
feign:
  compression:
    request:
      # 开启请求压缩
      enabled: true
      # 设置压缩的数据类型，此处也是默认值
      mime-types: text/html,application/xml,application/json
      # 设置触发压缩的大小下限，此处也是默认值
      min-request-size: 2048
    response:
      # 开启响应压缩
      enabled: true
```



## 6、Feign 日志级别配置

### 步骤1：开启 Feign 日志功能及级别

- FeignLog.java

```java
@Configuration
public class FeignLog {
    @Bean
    Logger.Level feignLevel() {
        // Feign ⽇志级别
        // NONE：默认的，不显示任何⽇志（性能最好）
        // BASIC：仅记录请求⽅法、URL、响应状态码以及执⾏时间（⽣产问题追踪）
        // HEADERS：在BASIC级别的基础上，记录请求和响应的header
        // FULL：记录请求和响应的header、body和元数据（适⽤于开发及测试环境定位问题）
        return Logger.Level.FULL;
    }
}
```



### 步骤2：配置 logging 日志级别为 debug

- application.yml

```yaml
# Feign 日志级别配置
logging:
  level:
    # Feign 日志只会对日志级别为 debug 的做出响应
    com.lagou.edu.controller.service.ResumeServiceFeignClient: debug
```



## 7、Feign 源码分析

### 7.1 @EnableFeignClients

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(FeignClientsRegistrar.class)
public @interface EnableFeignClients {
	.....
}
```



### 7.2 FeignClientsRegistrar.java

```java
// 实现 ImportBeanDefinitionRegistrar 接口，重写 registerBeanDefinitions 方法，完成一些 bean 的注入
class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar,ResourceLoaderAware, EnvironmentAware {
 	 .....

   @Override
   public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {
      // 把 FeignClient 的全局默认配置注入到容器
      registerDefaultConfiguration(metadata, registry);
     
      // 把标记了 @FeignClient 的类，创建对象，并注入到容器（针对添加了 @FeignClient 注解的接口操作）
      registerFeignClients(metadata, registry);
   }
   
   ....
}
```



#### （1）registerDefaultConfiguration 方法

- 把 @EnableFeignClients 中的 defaultConfiguration 属性中配置的 class 类型注入到容器

```java
private void registerDefaultConfiguration(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {
   Map<String, Object> defaultAttrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName(), true);

   if (defaultAttrs != null && defaultAttrs.containsKey("defaultConfiguration")) {
      String name;
      if (metadata.hasEnclosingClass()) {
         name = "default." + metadata.getEnclosingClassName();
      }else {
         name = "default." + metadata.getClassName();
      }
     
      registerClientConfiguration(registry, name,defaultAttrs.get("defaultConfiguration"));
   }
}
```

- registerClientConfiguration 方法

```java
private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name,Object configuration) {
   BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(FeignClientSpecification.class);
   builder.addConstructorArgValue(name);
   builder.addConstructorArgValue(configuration);
   registry.registerBeanDefinition(name + "." + FeignClientSpecification.class.getSimpleName(),builder.getBeanDefinition());
}
```



#### （2）registerFeignClients 方法

```java
public void registerFeignClients(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {
   ClassPathScanningCandidateComponentProvider scanner = getScanner();
  
   // 定义扫描器，主要是想扫描 @FeignClient 注解
   scanner.setResourceLoader(this.resourceLoader);

   Set<String> basePackages;

   Map<String, Object> attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName());
   AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(FeignClient.class);
   final Class<?>[] clients = attrs == null ? null: (Class<?>[]) attrs.get("clients");
   
  if (clients == null || clients.length == 0) {
      scanner.addIncludeFilter(annotationTypeFilter);
      basePackages = getBasePackages(metadata);
   }else {
      final Set<String> clientClasses = new HashSet<>();
      basePackages = new HashSet<>();
    
      for (Class<?> clazz : clients) {
         basePackages.add(ClassUtils.getPackageName(clazz));
         clientClasses.add(clazz.getCanonicalName());
      }
    
      AbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() {
         @Override
         protected boolean match(ClassMetadata metadata) {
            String cleaned = metadata.getClassName().replaceAll("\\$", ".");
            return clientClasses.contains(cleaned);
         }
      };
      scanner.addIncludeFilter(new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));
   }

   // 使用扫描器扫描 @FeignClient 注解标识的类
   // 在 basePackage 指定的目录中扫描，如果不指定的话，按照 SpringBoot 规则扫描
   for (String basePackage : basePackages) {
      Set<BeanDefinition> candidateComponents = scanner.findCandidateComponents(basePackage);
      for (BeanDefinition candidateComponent : candidateComponents) {
         if (candidateComponent instanceof AnnotatedBeanDefinition) {
            // verify annotated class is an interface
            AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;
            AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();
            Assert.isTrue(annotationMetadata.isInterface(),"@FeignClient can only be specified on an interface");

            Map<String, Object> attributes = annotationMetadata.getAnnotationAttributes(FeignClient.class.getCanonicalName());

            String name = getClientName(attributes);
           
            // 取出 @FeignClient 注解中的一个配置属性 configuration，取出来注入到容器
            registerClientConfiguration(registry, name,attributes.get("configuration"));
           
            // 注入 FeignClient 客户端对象，这个对象也是 controller 中使用的对象
            registerFeignClient(registry, annotationMetadata, attributes);
         }
      }
   }
}
```

- registerFeignClient 方法

```java
// 封装 BeanDefinition 对象（根据 @FeignClient 注解中的属性配置）
private void registerFeignClient(BeanDefinitionRegistry registry,AnnotationMetadata annotationMetadata, Map<String, Object> attributes) {
  
   String className = annotationMetadata.getClassName();
   
   // 客户端对象是 FeignClientFactoryBean，是一个 FactoryBean
   // 使用的时候，从容器中获取到的对象是 FactoryBean.getObject 返回的对象，该对象就是对应接口的代理对象
   BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class);
   
   validate(attributes);
  
   definition.addPropertyValue("url", getUrl(attributes));
   definition.addPropertyValue("path", getPath(attributes));
  
   String name = getName(attributes);
   definition.addPropertyValue("name", name);
  
   String contextId = getContextId(attributes);
   definition.addPropertyValue("contextId", contextId);
  
   definition.addPropertyValue("type", className);
   definition.addPropertyValue("decode404", attributes.get("decode404"));
   definition.addPropertyValue("fallback", attributes.get("fallback"));
   definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));
   definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);

   String alias = contextId + "FeignClient";
   AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();

   boolean primary = (Boolean)attributes.get("primary"); // has a default, won't be null

   beanDefinition.setPrimary(primary);

   String qualifier = getQualifier(attributes);
   if (StringUtils.hasText(qualifier)) {
      alias = qualifier;
   }

   BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,new String[] { alias });
   BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
}
```

- 关注 FeignClientFactoryBean 这个⼯⼚ Bean 的 getObject ⽅法、
- 跳转到 FeignClientFactoryBean.java

```java
@Override
public Object getObject() throws Exception {
   return getTarget();
}
```

- 关注 getTarget() 方法

```java
<T> T getTarget() {
   FeignContext context = applicationContext.getBean(FeignContext.class);
   Feign.Builder builder = feign(context);

   if (!StringUtils.hasText(this.url)) {
      if (!this.name.startsWith("http")) {
         url = "http://" + this.name;
      }else {
         url = this.name;
      }
     
      url += cleanPath();
      return (T) loadBalance(builder, context, new HardCodedTarget<>(this.type,this.name, url));
   }
  
   // 判断 @FeignClient 注解的 url 属性是否为空
   // url 为空的话，生成的 FeignClient 客户端对象就应该是一个带有负载均衡功能的客户端对象 feign + ribbon
   if (StringUtils.hasText(this.url) && !this.url.startsWith("http")) {
      this.url = "http://" + this.url;
   }
  
   String url = this.url + cleanPath();
   Client client = getOptional(context, Client.class);
   if (client != null) {
      if (client instanceof LoadBalancerFeignClient) {
         // not load balancing because we have a url,
         // but ribbon is on the classpath, so unwrap
         client = ((LoadBalancerFeignClient)client).getDelegate();
      }
      builder.client(client);
   }
  
   Targeter targeter = get(context, Targeter.class);
   return (T) targeter.target(this, builder, context, new HardCodedTarget<>(this.type, this.name, url));
}
```

- 关注 loadBalance 方法

```java
protected <T> T loadBalance(Feign.Builder builder, FeignContext context,HardCodedTarget<T> target) {
   // 使用 build 构造器包装 client
   Client client = getOptional(context, Client.class);
  
   if (client != null) {
      builder.client(client);
      Targeter targeter = get(context, Targeter.class);
      return targeter.target(this, builder, context, target);
   }

   throw new IllegalStateException("No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?");
}
```

- 关注 target 方法
- 跳转到实现类 HystrixTargeter.java

```java
@Override
public <T> T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,Target.HardCodedTarget<T> target) {
  
   if (!(feign instanceof feign.hystrix.HystrixFeign.Builder)) {
      return feign.target(target);
   }
  
   feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign;
   SetterFactory setterFactory = getOptional(factory.getName(), context,SetterFactory.class);
  
   if (setterFactory != null) {
      builder.setterFactory(setterFactory);
   }
  
   Class<?> fallback = factory.getFallback();
   if (fallback != void.class) {
      return targetWithFallback(factory.getName(), context, target, builder, fallback);
   }
  
   Class<?> fallbackFactory = factory.getFallbackFactory();
   if (fallbackFactory != void.class) {
      return targetWithFallbackFactory(factory.getName(), context, target, builder, fallbackFactory);
   }

   return feign.target(target);
}
```

- 关注 feign.target(target) 方法
- 跳转到 Feign.java

```java
public <T> T target(Target<T> target) {
  return build().newInstance(target);
}
```

- 关注 newInstance 方法
- 跳转到实现类 ReflectiveFeign.java

```java
@Override
public <T> T newInstance(Target<T> target) {
  Map<String, MethodHandler> nameToHandler = targetToHandlersByName.apply(target);
  Map<Method, MethodHandler> methodToHandler = new LinkedHashMap<Method, MethodHandler>();
  List<DefaultMethodHandler> defaultMethodHandlers = new LinkedList<DefaultMethodHandler>();

  for (Method method : target.type().getMethods()) {
    if (method.getDeclaringClass() == Object.class) {
      continue;
    } else if (Util.isDefault(method)) {
      DefaultMethodHandler handler = new DefaultMethodHandler(method);
      defaultMethodHandlers.add(handler);
      methodToHandler.put(method, handler);
    } else {
      methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));
    }
  }
  
  InvocationHandler handler = factory.create(target, methodToHandler);
  
  // newProxyInstance 使用动态代理生成对象（通过debug得知，增强逻辑在 FeignInvocationHandler）
  T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),new Class<?>[] {target.type()}, handler);

  for (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {
    defaultMethodHandler.bindTo(proxy);
  }
  return proxy;
}
```



### 7.3 ReflectiveFeign.java（FeignInvocationHandler）

```java
static class FeignInvocationHandler implements InvocationHandler {
  private final Target target;
  private final Map<Method, MethodHandler> dispatch;

  FeignInvocationHandler(Target target, Map<Method, MethodHandler> dispatch) {
    this.target = checkNotNull(target, "target");
    this.dispatch = checkNotNull(dispatch, "dispatch for %s", target);
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if ("equals".equals(method.getName())) {
      try {
        Object otherHandler =args.length > 0 && args[0] != null ? Proxy.getInvocationHandler(args[0]) : null;
        return equals(otherHandler);
      } catch (IllegalArgumentException e) {
        return false;
      }
    } else if ("hashCode".equals(method.getName())) {
      return hashCode();
    } else if ("toString".equals(method.getName())) {
      return toString();
    }
    // 具体的方法增强逻辑又交给了对应的 SynchronousMethodHandler 来处理
    // 由返回的 value 类型可知是 SynchronousMethodHandler（debug模式可以看到）
    return dispatch.get(method).invoke(args);
  }

  @Override
  public boolean equals(Object obj) {
    if (obj instanceof FeignInvocationHandler) {
      FeignInvocationHandler other = (FeignInvocationHandler) obj;
      return target.equals(other.target);
    }
    return false;
  }

  @Override
  public int hashCode() {
    return target.hashCode();
  }

  @Override
  public String toString() {
    return target.toString();
  }
}
```



### 7.4 SynchronousMethodHandler.java

```java
@Override
public Object invoke(Object[] argv) throws Throwable {
  RequestTemplate template = buildTemplateFromArgs.create(argv);
  Retryer retryer = this.retryer.clone();
  
  while (true) {
    try {
      // 执行后续逻辑请求
      return executeAndDecode(template);
    } catch (RetryableException e) {
      try {
        retryer.continueOrPropagate(e);
      } catch (RetryableException th) {
        Throwable cause = th.getCause();
        
        if (propagationPolicy == UNWRAP && cause != null) {
          throw cause;
        } else {
          throw th;
        }
      }
      
      if (logLevel != Logger.Level.NONE) {
        logger.logRetry(metadata.configKey(), logLevel);
      }
      
      continue;
    }
  }
}
```

- 追踪 executeAndDecode 方法

```java
Object executeAndDecode(RequestTemplate template) throws Throwable {
  Request request = targetRequest(template);

  if (logLevel != Logger.Level.NONE) {
    logger.logRequest(metadata.configKey(), logLevel, request);
  }

  Response response;
  long start = System.nanoTime();
  try {
    // 执行 
    response = client.execute(request, options);
  } catch (IOException e) {
    if (logLevel != Logger.Level.NONE) {
      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));
    }
    throw errorExecuting(request, e);
  }
  
  long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);

  boolean shouldClose = true;
  try {
    if (logLevel != Logger.Level.NONE) {
      response = logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);
    }
    if (Response.class == metadata.returnType()) {
      if (response.body() == null) {
        return response;
      }
      
      if (response.body().length() == null || response.body().length() > MAX_RESPONSE_BUFFER_SIZE) {
        shouldClose = false;
        return response;
      }
      
      // Ensure the response body is disconnected
      byte[] bodyData = Util.toByteArray(response.body().asInputStream());
      return response.toBuilder().body(bodyData).build();
    }
    
    if (response.status() >= 200 && response.status() < 300) {
      if (void.class == metadata.returnType()) {
        return null;
      } else {
        Object result = decode(response);
        shouldClose = closeAfterDecode;
        return result;
      }
    } else if (decode404 && response.status() == 404 && void.class != metadata.returnType()) {
      Object result = decode(response);
      shouldClose = closeAfterDecode;
      return result;
    } else {
      throw errorDecoder.decode(metadata.configKey(), response);
    }
  } catch (IOException e) {
    if (logLevel != Logger.Level.NONE) {
      logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);
    }
    throw errorReading(request, response, e);
  } finally {
    if (shouldClose) {
      ensureClosed(response.body());
    }
  }
}
```

- 追踪 execute 方法
- 跳转到 LoadBalancerFeignClient.java

```java
@Override
public Response execute(Request request, Request.Options options) throws IOException {
   try {
      URI asUri = URI.create(request.url());
      String clientName = asUri.getHost();
      URI uriWithoutHost = cleanUrl(request.url(), clientName);
      // 构建 ribbon 请求对象
      FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest(this.delegate, request, uriWithoutHost);

      IClientConfig requestConfig = getClientConfig(options, clientName);
     
      // 后续处理，包括负载均衡等 
      return lbClient(clientName).executeWithLoadBalancer(ribbonRequest,requestConfig).toResponse();
   }catch (ClientException e) {
      IOException io = findIOException(e);
      if (io != null) {
         throw io;
      }
      throw new RuntimeException(e);
   }
}
```

- 追踪 executeWithLoadBalancer 方法

```java
public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException {
    LoadBalancerCommand<T> command = buildLoadBalancerCommand(request, requestConfig);

    try {
        return command.submit(
            // ServerOperation 对象（服务实例操作对象）
            new ServerOperation<T>() {
                @Override
                public Observable<T> call(Server server) {
                    URI finalUri = reconstructURIWithServer(server, request.getUri());
                    S requestForServer = (S) request.replaceUri(finalUri);
                    try {
                        return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));
                    } 
                    catch (Exception e) {
                        return Observable.error(e);
                    }
                }
            })
            .toBlocking()
            .single();
    } catch (Exception e) {
        Throwable t = e.getCause();
        if (t instanceof ClientException) {
            throw (ClientException) t;
        } else {
            throw new ClientException(e);
        }
    }
}
```

- 追踪 submit 方法
- 跳转到 LoadBalancerCommand.java

```java
public Observable<T> submit(final ServerOperation<T> operation) {
    final ExecutionInfoContext context = new ExecutionInfoContext();
    
    if (listenerInvoker != null) {
        try {
            listenerInvoker.onExecutionStart();
        } catch (AbortExecutionException e) {
            return Observable.error(e);
        }
    }

    final int maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();
    final int maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();

    // Use the load balancer
    // 进行负载均衡选择实例 
    Observable<T> o = (server == null ? selectServer() : Observable.just(server)).concatMap(new Func1<Server, Observable<T>>() {
     ......
}
```

- 追踪 selectServer 方法

```java
private Observable<Server> selectServer() {
    return Observable.create(new OnSubscribe<Server>() {
        @Override
        public void call(Subscriber<? super Server> next) {
            try {
                Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   
                next.onNext(server);
                next.onCompleted();
            } catch (Exception e) {
                next.onError(e);
            }
        }
    });
}
```

- 追踪 getServerFromLoadBalancer 方法

```java
public Server getServerFromLoadBalancer(@Nullable URI original, @Nullable Object loadBalancerKey) throws ClientException {
    String host = null;
    int port = -1;
    if (original != null) {
        host = original.getHost();
    }
    if (original != null) {
        Pair<String, Integer> schemeAndPort = deriveSchemeAndPortFromPartialUri(original);        
        port = schemeAndPort.second();
    }

    // 来到 Ribbon 的逻辑，ZoneAwareLoadBalancer，通过它调用负载均衡策略，完成 server 的选择
    ILoadBalancer lb = getLoadBalancer();
    if (host == null) {
        // Partial URI or no URI Case
        // well we have to just get the right instances from lb - or we fall back
        if (lb != null){
            Server svc = lb.chooseServer(loadBalancerKey);
            if (svc == null){
                throw new ClientException(ClientException.ErrorType.GENERAL,
                        "Load balancer does not have available server for client: "
                                + clientName);
            }
          
          ......
```



# 第五章 网关 - Spring Cloud GateWay

## 1、GateWay 简介

### 1.1 GateWay 概述

- Spring Cloud GateWay 是Spring Cloud 的⼀个全新项⽬，⽬标是取代 Netflflix Zuul
- 基于Spring5.0 + SpringBoot2.0 + WebFlux 等技术开发，基于⾼性能的 Reactor 模式响应式通信框架 Netty，异步⾮阻塞模型，性能⾼于Zuul
- 旨在为微服务架构提供⼀种简单有效的统⼀的 API 路由管理⽅式（网关转发请求到下游的微服务，叫做 API 路由）
- Spring Cloud GateWay 不仅提供统⼀的路由⽅式（反向代理）并且基于 Filter 链（定义过滤器对请求过滤，完成⼀些功能）的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控等。

![image-20211111154148512](image/image-20211111154148512.png)

### 1.2 GateWay 在架构中的位置

![image-20211111134734199](image/image-20211111134734199.png)



## 2、GateWay 核心概念 - 路由（route）

### 2.1 路由概念

- 路由（route）： ⽹关最基础的部分，也是⽹关⽐较基础的⼯作单元
- 路由由⼀个ID、⼀个⽬标URL（最终路由到的地址）、⼀系列的断⾔（匹配条件判断）和Filter过滤器（精细化控制）组成
- 如果断⾔为true，则匹配该路由



### 2.2 路由规则

- Spring Cloud GateWay 内置了很多 Predicates功能，实现了各种路由匹配规则（通过 Header、请求参数等作为条件）匹配到对应的路由

#### （1）时间点后匹配

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: after_route
        uri: https://example.org
        predicates:
          - After=2017-01-20T17:42:47.789-07:00[America/Denver]
```

#### （2）时间点前匹配

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: before_route
        uri: https://example.org
        predicates:
          - Before=2017-01-20T17:42:47.789-07:00[America/Denver]
```

#### （3）时间区间匹配

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: between_route
        uri: https://example.org
        predicates:
          - Between=2017-01-20T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver]
```

#### （4）指定 Cookie 正则匹配指定值

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: cookie_route
        uri: https://example.org
        predicates:
          - Cookie=chocolate, ch.p
```

#### （5）指定 Header 正则匹配指定值

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: header_route
        uri: https://example.org
        predicates:
          - Header=X-Request-Id, \d+
```

#### （6）请求 Host 匹配指定值

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: host_route
        uri: https://example.org
        predicates:
          - Host=**.somehost.org,**.anotherhost.org
```

#### （7）请求 Method 匹配指定请求方式

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: method_route
        uri: https://example.org
        predicates:
          - Method=GET,POST
```

#### （8）请求路径正则匹配

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: path_route
          uri: https://example.org
        predicates:
          - Path=/red/{segment},/blue/{segment}
```

#### （9）请求包含某参数

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: query_route
        uri: https://example.org
        predicates:
          - Query=green
```

#### （10）请求包含某参数，并且参数值匹配正则表达式

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: query_route
          uri: https://example.org
          predicates:
            - Query=red, gree.
```

#### （11）远程地址匹配

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: remoteaddr_route
          uri: https://example.org
          predicates:
            - RemoteAddr=192.168.1.1/24
```



### 2.3 动态路由

- GateWay ⽀持⾃动从注册中⼼中获取服务列表并访问，即所谓的动态路由



#### 步骤1：pom.xml中添加注册中心客户端依赖

- 因为要获取注册中⼼服务列表，eureka 客户端已经引⼊

```xml
<!-- eureka client -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```



#### 步骤2：动态路由配置（application.yml）

- 动态路由设置时，uri以 lb: //开头（lb代表从注册中⼼获取服务），后⾯是需要转发到的服务名称

```yaml
Spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      # 路由可以有多个
      routes:
        # 自定义的路由 ID，保持唯一
        - id: service-autodeliver-router
          # 目标服务地址
          # uri: http://127.0.0.1:8096
          # 动态路由：uri 配置为服务名称（gateway 网关从服务注册中心获取实例信息，负载后路由）
          uri: lb://resume-service-autodeliver
          # 断言：路由条件，接受一个输入参数，返回一个布尔值结果。
          # 该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。
          predicates:
            - Path=/autodeliver/**
        # 自定义的路由 ID，保持唯一
        - id: service-resume-router
          uri: lb://resume-service-resume
          predicates:
            - Path=/resume/**
          # 过滤器（GateWayFilter：会对单个路由生效）
          # filters:
            # 作用：去掉 url 中的占位后转发路由（这里1表示去掉第一个占位字符串）
            #- StripPrefix=1
```



## 3、GateWay 核心概念 - 断言（predicates）

- 断⾔（predicates）：参考了 Java8 中的断⾔ java.util.function.Predicate
- 开发⼈员可以匹配 Http 请求中的所有内容（包括请求头、请求参数等）（类似于 nginx 中的 location 匹配⼀样），如果断⾔与请求相匹配则路由。



## 4、GateWay 核心概念 - 过滤器（filter）

- 过滤器（filter）：⼀个标准的 Spring webFilter，使⽤过滤器，可以在请求之前或者之后执⾏业务逻辑。



### 4.1 过滤器分类

#### （1）从过滤器生命周期点（影响时机点）的角度

```
pre
- 这种过滤器在请求被路由之前调⽤
- 可利⽤这种过滤器实现身份验证、在集群中选择 请求的微服务、记录调试信息等

post
- 这种过滤器在路由到微服务以后执⾏
- 可⽤来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等
```

#### （2）从过滤器类型的角度

```
GateWayFilter：影响范围为，应用到单个路由路由上
GlobalFilter：影响范围为，应用到所有的路由上
```



### 4.2 自定义全局过滤器

- GlobalFilter：自定义全局过滤器，会对所有路由生效

```java
// ⾃定义全局过滤器实现IP访问限制（黑白名单）
@Slf4j
@Component  // 让容器扫描到，等同于注册了
public class BlackListFilter implements GlobalFilter, Ordered {
    // 模拟黑名单（实际可以去数据库或者redis中查询）
    private static List<String> blackList = new ArrayList<>();

    static {
        // 模拟本机地址
        blackList.add("0:0:0:0:0:0:0:1");
    }

    /**
     * 过滤器核心方法
     *
     * @param exchange 封装了 request 和 response 对象的上下文
     * @param chain    网关过滤器链（包含全局过滤器和单路由过滤器）
     * @return
     */
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 思路：获取客户端ip，判断是否在黑名单中，在的话就拒绝访问，不在的话就放行
        // 从上下文中取出 request 和 response 对象
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();

        // 从 request 对象中获取客户端ip
        String clientIp = request.getRemoteAddress().getHostString();

        // 拿着 clientIp 去黑名单中查询，存在的话就拒绝访问
        if (blackList.contains(clientIp)) {
            // 拒绝访问，返回
            response.setStatusCode(HttpStatus.UNAUTHORIZED); // 状态码
            log.debug("=====>IP:" + clientIp + " 在黑名单中，将被拒绝访问！");

            String data = "Request be denied!";
            DataBuffer wrap = response.bufferFactory().wrap(data.getBytes());
            return response.writeWith(Mono.just(wrap));
        }

        // 合法请求，放行，执行后续的过滤器
        return chain.filter(exchange);
    }

    /**
     * 返回值表示当前过滤器的顺序(优先级)，数值越小，优先级越高
     *
     * @return
     */
    @Override
    public int getOrder() {
        return 0;
    }
}
```





## 5、GateWay 工作过程

![image-20211111153919329](image/image-20211111153919329.png)

- 客户端向 Spring Cloud GateWay 发出请求
- 然后在GateWay Handler Mapping中找到与请求相匹配的路由，将其发送到GateWay Web Handler；
- Handler再通过指定的过滤器链来将请求发送到实际的服务执⾏业务逻辑，然后返回。
- 过滤器之间⽤虚线分开是因为过滤器可能会在发送代理请求之前（pre）或者之后（post）执⾏业务逻辑。

```
- Filter在“pre”类型过滤器中可以做参数校验、权限校验、流量监控、⽇志输出、协议转换等
- 在“post”类型的过滤器中可以做响应内容、响应头的修改、⽇志的输出、流量监控等。
```

- GateWay核⼼逻辑：路由转发 + 执⾏过滤器链



## 6、GateWay 使用

### 步骤1：pom 依赖

- GateWay 不需要使⽤web模块，它引⼊的是 WebFlux（类似于SpringMVC）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <!-- spring boot 父启动器依赖-->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.6.RELEASE</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <artifactId>cloud-gateway-9002</artifactId>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

    <dependencies>
        <!--GateWay 网关-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>

        <!--引入webflux-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-commons</artifactId>
        </dependency>

        <!-- eureka client -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>

        <!--日志依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <!--测试依赖-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!--lombok工具-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.4</version>
            <scope>provided</scope>
        </dependency>

        <!--引入Jaxb，开始-->
        <dependency>
            <groupId>com.sun.xml.bind</groupId>
            <artifactId>jaxb-core</artifactId>
            <version>2.2.11</version>
        </dependency>

        <dependency>
            <groupId>javax.xml.bind</groupId>
            <artifactId>jaxb-api</artifactId>
        </dependency>

        <dependency>
            <groupId>com.sun.xml.bind</groupId>
            <artifactId>jaxb-impl</artifactId>
            <version>2.2.11</version>
        </dependency>

        <dependency>
            <groupId>org.glassfish.jaxb</groupId>
            <artifactId>jaxb-runtime</artifactId>
            <version>2.2.10-b140310.1920</version>
        </dependency>

        <dependency>
            <groupId>javax.activation</groupId>
            <artifactId>activation</artifactId>
            <version>1.1.1</version>
        </dependency>
        <!--引入Jaxb，结束-->

        <!-- Actuator可以帮助你监控和管理Spring Boot应用-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!--热部署-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <!--spring cloud依赖版本管理-->
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Greenwich.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <!--编译插件-->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                    <encoding>utf-8</encoding>
                </configuration>
            </plugin>

            <!--打包插件-->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
```



### 步骤2：yml 配置

```yaml
server:
  port: 9002

Spring:
  application:
    name: cloud-gateway
  cloud:
    gateway:
      # 路由可以有多个
      routes:
        # 自定义的路由 ID，保持唯一
        - id: service-autodeliver-router
          # 目标服务地址
          # uri: http://127.0.0.1:8096
          # 动态路由：uri 配置为服务名称（gateway 网关从服务注册中心获取实例信息，负载后路由）
          uri: lb://resume-service-autodeliver
          # 断言：路由条件，接受一个输入参数，返回一个布尔值结果。
          # 该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。
          predicates:
            - Path=/autodeliver/**
        # 自定义的路由 ID，保持唯一
        - id: service-resume-router
          uri: lb://resume-service-resume
          predicates:
            - Path=/resume/**
          # 过滤器（GateWayFilter：会对单个路由生效）
          # filters:
            # 作用：去掉 url 中的占位后转发路由（这里1表示去掉第一个占位字符串）
            #- StripPrefix=1

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



### 步骤3：启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class GateWayApplication9002 {
    public static void main(String[] args) {
        SpringApplication.run(GateWayApplication9002.class, args);
    }
}
```



## 7、GateWay 高可用

- 可以启动多个 GateWay 实例来实现⾼可用
- 在 GateWay 的上游使用 Nginx 等负载均衡设备进⾏负载转发以达到⾼可⽤的⽬的



- 启动多个GateWay实例（假如说两个，⼀个端⼝9002，⼀个端⼝9003），剩下的就是使⽤Nginx等完成负载代理即可

```properties
# 配置多个 GateWay 实例
upstream gateway {
 server 127.0.0.1:9002;
 server 127.0.0.1:9003;
}

location / {
 proxy_pass http://gateway;
}
```



# 第六章 服务配置中心 - Spring Cloud Config + Spring Cloud Bus

## 1、Config 分布式配置方案

- Server 端：提供配置⽂件的存储、以接⼝的形式将配置⽂件的内容提供出去，通过使⽤ @EnableConfigServer 注解在 Spring boot 应⽤中嵌⼊
- Client 端：通过接⼝获取配置数据并初始化⾃⼰的应⽤

![image-20211111185948419](image/image-20211111185948419.png)



## 2、Config 配置中心搭建

### 步骤1：创建存储配置文件的项目

- 使用 git/gitee 创建存储配置文件的项目

- 在仓库中上传 yml 配置文件，命名规则如下

```properties
# application为应⽤名称
# profile 指的是环境（⽤于区分开发环境，测试环境、⽣产环境等）
{application}-{profile}.yml 或者 {application}-{profile}.properties

# 举例
resume-service-resume-dev.yml
resume-service-resume-test.yml
resume-service-resume-prod.yml
```



### 步骤2：项目引入依赖

```xml
<dependencies>
    <!-- eureka client 客户端依赖引入-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <!-- config 配置中心服务端 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-config-server</artifactId>
    </dependency>
</dependencies>
```



### 步骤3：启动类配置注解

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableConfigServer  // 开启配置中心功能
public class ConfigServerApplication9003 {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication9003.class, args);
    }
}
```



### 步骤4：application.yml

```yaml
Spring:
  cloud:
    config:
      server:
        git:
          # 配置 git 服务地址
          uri: https://gitee.com/shorfng/cloud-config-repo.git
          # 配置 git 用户名
          username: xxxxx
          # 配置 git 密码
          password: xxxx
          search-paths:
            - cloud-config-repo
      # 读取 git 分支
      label: main
```



### 步骤5：测试 - 访问配置文件内容

- http://ip:端口号/分支名称/配置文件名称

- http://localhost:9003/main/resume-service-resume-dev.yml



## 3、Config 客户端搭建

### 步骤1：客户端工程添加依赖

- 在本次举例中，修改客户端 resume-service-resume-8080 和 resume-service-resume-8081 项目中的 pom.xml 即可

```xml
<!--Config 客户端依赖-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-config-client</artifactId>
</dependency>
```



### 步骤2：bootstrap.yml

- 因为 bootstrap.yml 是系统级别的，优先级比 application.yml 高，应⽤启动时会检查这个配置⽂件，在这个 bootstrap.yml 配置⽂件中指定配置中⼼的服务地址，会⾃动拉取所有应⽤配置并且启⽤，所以修改 application.yml 为 bootstrap.yml

```yaml
spring:
 cloud:
    # config 客户端配置（和 cloud-config-server-9003 通信，并告知希望获取的配置信息在哪个文件中）
    config:
      # git 上的配置文件名称
      name: resume-service-resume
      profile: dev  # 后缀名称
      label: main   # 分支名称
      # cloud-config-server 配置中心地址
      uri: http://localhost:9003
```



### 步骤3：config 配置中心的配置信息

```java
@RestController
@RequestMapping("/config")
public class ConfigController {
    @Value("${mysql.url}")
    private String mysqlUrl;

    @Value("${td.message}")
    private String tdMessage;

    //http://localhost:8080/config/viewconfig
    @GetMapping("/viewconfig")
    public String viewconfig() {
        return "tdMessage==>" + tdMessage + " mysqlUrl=>" + mysqlUrl;
    }
}
```



### 步骤4：测试

- http://localhost:8080/config/viewconfig



## 4、Config 客户端手动刷新方案

- 原因：当修改 GitHub 上⾯的值时，服务端（Config Server）能实时获取最新的值，但客户端（Config Client）读的是缓存，⽆法实时获取最新值
- 效果：不⽤重启微服务，只需要⼿动的做⼀些其他的操作（访问⼀个地址/refresh）刷新，之后再访问即可
- 方案：客户端使用 post 触发 refresh，获取最新数据



### 步骤1：添加依赖

- Client 客户端添加依赖 springboot-starter-actuator

```xml
<!-- Actuator可以帮助你监控和管理Spring Boot应⽤-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```



### 步骤2：bootstrap.yml 暴露通信端点

- Client客户端 bootstrap.yml 中添加配置（暴露通信端点）

```yaml
# 暴露通信端口
management:
  endpoints:
    web:
      exposure:
        # include: refresh
        # *表示暴露所有端口
        include: "*"
```



### 步骤3：添加 @RefreshScope 注解

- Client 客户端使⽤到配置信息的类上添加 @RefreshScope

```java
@RestController
@RequestMapping("/config")
@RefreshScope
public class ConfigController {
    @Value("${mysql.url}")
    private String mysqlUrl;

    @Value("${td.message}")
    private String tdMessage;

    //http://localhost:8080/config/viewconfig
    @GetMapping("/viewconfig")
    public String viewconfig() {
        return "tdMessage==>" + tdMessage + " mysqlUrl=>" + mysqlUrl;
    }
}
```



### 步骤4：客户端使用 post 触发 refresh

- http://localhost:8080/actuator/refresh



## 5、Config 客户端自动刷新方案 - Spring Cloud Config + Spring Cloud Bus

### 5.1 Spring Cloud Bus（消息总线）

- 消息总线Bus，即经常会使⽤MQ消息代理构建⼀个共⽤的 Topic，通过这个 Topic 连接各个微服务实例，MQ⼴播的消息会被所有在注册中⼼的微服务实例监听和消费。换⾔之就是通过⼀个主题连接各个微服务，打通脉络。
- Spring Cloud Bus（基于MQ的，⽀持RabbitMq/Kafka） 是Spring Cloud中的消息总线⽅案
- Spring Cloud Config + Spring Cloud Bus 结合可以实现配置信息的⾃动更新。



### 5.2 Config + Bus 使用方案

![image-20211111190542194](image/image-20211111190542194.png)





### 5.2 Config + Bus 使用步骤

#### 步骤1：添加 Spring Cloud Bus 依赖

- cloud-config-server-9003
- resume-service-resume-8081

```xml
<!-- Spring Cloud Bus -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bus-amqp</artifactId>
</dependency>
```



#### 步骤2：application.yml 添加 rabbitmq 配置

- cloud-config-server-9003
- resume-service-resume-8081

```yaml
Spring:
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
```



#### 步骤3：application.yml 暴露通信端口

- cloud-config-server-9003

```yaml
# 暴露通信端口
management:
  endpoints:
    web:
      exposure:
        # include: refresh
        # *表示暴露所有端口
        include: "*"
```



#### 步骤4：ConfigController.java 配置 @RefreshScope 注解

- resume-service-resume-8081

```java
@RestController
@RequestMapping("/config")
@RefreshScope
public class ConfigController {
    @Value("${mysql.url}")
    private String mysqlUrl;

    @Value("${td.message}")
    private String tdMessage;

    //http://localhost:8081/config/viewconfig
    @GetMapping("/viewconfig")
    public String viewconfig() {
        return "tdMessage==>" + tdMessage + " mysqlUrl=>" + mysqlUrl;
    }
}
```



#### 步骤5：刷新所有实例（使用 post 触发 refresh）

- cloud-config-server-9003
- http://localhost:9003/actuator/bus-refresh



#### 步骤6：定向刷新指定实例（使用 post 触发 refresh）

- http://localhost:9003/actuator/bus-refresh/要刷新的服务名:要刷新的端口号

- http://localhost:9003/actuator/bus-refresh/resume-service-resume:8081



# 第七章 消息驱动 - Spring Cloud Stream

## 1、Stream 简介

### 1.1 Stream  概述

- Spring Cloud Stream 是⼀个构建消息驱动微服务的框架。
- 应⽤程序通过inputs（相当于消息消费者consumer）或者 outputs（相当于消息⽣产者producer）来与 Spring Cloud Stream 中的 binder 对象交互
- Binder 对象是⽤来屏蔽底层不同MQ消息中间件的细节差异，它负责与具体的消息中间件交互，当需要更换为其他消息中间件时，更换对应的Binder绑定器⽽不需要修改任何应⽤逻辑（Binder绑定器的实现是框架内置的）
- Spring Cloud Stream⽬前⽀持Rabbit、Kafka两种消息队列

![image-20211112113900396](image/image-20211112113900396.png)



### 1.2 传统MQ模型与Stream消息驱动模型

- 传统MQ模型

![image-20211112114207037](image/image-20211112114207037.png)

- Stream消息驱动模型

![image-20211112114228507](image/image-20211112114228507.png)



### 1.3 Stream消息通信方式

- Stream中的消息通信⽅式遵循了发布—订阅模式。
- 当⼀条消息被投递到消息中间件之 后，它会通过共享的 Topic 主题进⾏⼴播，消息消费者在订阅的主题中收到它并触发⾃身的业务逻辑处理
- 这⾥所提到的 Topic 主题是Spring Cloud Stream中的⼀个抽象概念，⽤来代表发布共享消息给消 费者的地⽅。在不同的消息中间件中， Topic 可能对应着不同的概念，⽐如：在RabbitMQ中的它对应了Exchange、在Kakfa中则对应了Kafka中的Topic



### 1.4 Stream 编程相关注解

#### @Input

- 在消费者⼯程中使⽤
- 注解标识输⼊通道，通过该输⼊通道接收到的消息进⼊应⽤程序

#### @Output

- 在⽣产者⼯程中使⽤
- 注解标识输出通道，发布的消息将通过该通道离开应⽤程序

#### @StreamListener

- 在消费者⼯程中使⽤，监听message的到来
- 监听队列，⽤于消费者的队列的消息的接收（有消息监听.....）

#### @EnableBinding 

- 对于RabbitMQ：把 Channel 和 Exchange 绑定在⼀起



## 2、Stream 构建生产者

### 步骤1：pom 依赖

```xml
<!--eureka client 客户端依赖引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<!-- spring cloud stream 依赖（rabbit）-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>
```



### 步骤2：启动类

- StreamProducerApplication9090

```java
@SpringBootApplication
@EnableDiscoveryClient
public class StreamProducerApplication9090 {
    public static void main(String[] args) {
        SpringApplication.run(StreamProducerApplication9090.class, args);
    }
}
```



### 步骤3：application.yml

```yaml
server:
  port: 9090

spring:
  application:
    name: cloud-stream-producer
  cloud:
    stream:
      binders: # 绑定 MQ服务信息（此是 RabbitMQ）
        # 自定义 Binder 名称，用于后面的关联
        TDRabbitBinder:
          # MQ 类型，如果是 Kafka，此处配置 kafka
          type: rabbit
          # MQ 环境配置（用户名、密码等）
          environment:
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      # 关联整合通道和 binder对象
      bindings:
        # 定义的通道名称，此处不能乱改
        output:
          # 要使用的Exchange名称（消息队列主题名称）
          destination: TDExchange
          # 消息类型设置
          # content-type: application/json
          content-type: text/plain
          # 关联 MQ 服务
          binder: TDRabbitBinder

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



### 步骤4：生产者

- IMessageProducer

```java
public interface IMessageProducer {
    public void sendMessage(String content);
}
```

- MessageProducerImpl

```java
package com.loto.service.impl;

import com.loto.service.IMessageProducer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.stream.annotation.EnableBinding;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.messaging.support.MessageBuilder;

// Source.class 里面是对输出通道的定义（这是 Spring Cloud Stream 内置的通道封装）
@EnableBinding(Source.class)
public class MessageProducerImpl implements IMessageProducer {
    // 将MessageChannel 的封装对象 Source 注入到这里使用
    @Autowired
    private Source source;

    @Override
    public void sendMessage(String content) {
        // 向 mq 中发送消息（并不是直接操作 mq，而是通过 spring cloud stream 操作的）
        // 使用通道向外发出消息(指的是 Source 里面的 output 通道)
        source.output().send(MessageBuilder.withPayload(content).build());
    }
}
```



### 步骤5：测试类

```java
@SpringBootTest(classes = {StreamProducerApplication9090.class})
@RunWith(SpringJUnit4ClassRunner.class)
public class MessageProducerTest {
    @Autowired
    private IMessageProducer iMessageProducer;

    @Test
    public void testSendMessage() {
        iMessageProducer.sendMessage("hello world,Spring Cloud Stream");
    }
}
```



## 3、Stream 构建消费者

### 步骤1：pom 依赖

```xml
<!--eureka client 客户端依赖引入-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>

<!-- spring cloud stream 依赖（rabbit）-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>
```



### 步骤2：启动类

- StreamProducerApplication9091

```java
@SpringBootApplication
@EnableDiscoveryClient
public class StreamConsumerApplication9091 {
    public static void main(String[] args) {
        SpringApplication.run(StreamConsumerApplication9091.class, args);
    }
}
```



### 步骤3：application.yml

```yaml
server:
  port: 9091

spring:
  application:
    name: cloud-stream-consumer
  cloud:
    stream:
      binders: # 绑定 MQ服务信息（此是 RabbitMQ）
        # 自定义 Binder 名称，用于后面的关联
        TDRabbitBinder:
          # MQ 类型，如果是 Kafka，此处配置 kafka
          type: rabbit
          # MQ 环境配置（用户名、密码等）
          environment:
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      # 关联整合通道和 binder对象
      bindings:
        # 定义的通道名称，此处不能乱改
        input:
          # 要使用的Exchange名称（消息队列主题名称）
          destination: TDExchange
          # 消息类型设置
          # content-type: application/json
          content-type: text/plain
          # 关联 MQ 服务
          binder: TDRabbitBinder
          # 多个消费者实例配置为同⼀个 group 名称，能解决消息重复消费问题
          group: tdgroup01

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



### 步骤4：消费者

```java
@EnableBinding(Sink.class)
public class MessageConsumerService {
    @StreamListener(Sink.INPUT)
    public void receiveMessages(Message<String> message) {
        System.out.println("========= 9091接收到的消息：" + message);
    }
}
```



## 4、Stream 自定义消费通道

// TODO



## 5、Stream 消息分组

### 问题描述

- 如果，消费者端有两个（消费同⼀个MQ的同⼀个主题），但是业务场景中希望这个主题的⼀个Message只能被⼀个消费者端消费处理，此时
  就可以使⽤消息分组。

### 解决方案

- 消息分组能解决消息重复消费问题

```yaml
# 在服务消费者端设置 spring.cloud.stream.bindings.input.group 属性
# 多个消费者实例配置为同⼀个group名称（在同⼀个group中的多个消费者只有⼀个可以获取到消息并消费）

spring:
  application:
    name: cloud-stream-consumer
  cloud:
    stream:
      binders: # 绑定 MQ服务信息（此是 RabbitMQ）
        # 自定义 Binder 名称，用于后面的关联
        TDRabbitBinder:
          # MQ 类型，如果是 Kafka，此处配置 kafka
          type: rabbit
          # MQ 环境配置（用户名、密码等）
          environment:
            spring:
              rabbitmq:
                host: localhost
                port: 5672
                username: guest
                password: guest
      # 关联整合通道和 binder对象
      bindings:
        # 定义的通道名称，此处不能乱改
        input:
          # 要使用的Exchange名称（消息队列主题名称）
          destination: TDExchange
          # 消息类型设置
          # content-type: application/json
          content-type: text/plain
          # 关联 MQ 服务
          binder: TDRabbitBinder
          # 多个消费者实例配置为同⼀个 group 名称，能解决消息重复消费问题
          group: tdgroup01
```



# 第八章 分布式链路追踪 - Spring Cloud Sleuth + Twitter Zipkin

## 1、分布式链路追踪简介

### 1.1 分布式链路追踪技术 - 概述

#### （1）引入

```
- 如何动态展示服务的调⽤链路？
- 如何分析服务调⽤链路中的瓶颈节点并对其进⾏调优？
- 如何快速进⾏服务链路的故障发现？
```

#### （2）概念

- 在⼀个请求的调⽤处理过程中，在各个链路节点都能够记录下⽇志，并最终将⽇志进⾏集中可视化展示

- 比如：请求到达哪个服务实例？请求被处理的状态怎样？处理耗时怎样？
- 分布式环境下基于这种想法实现的监控技术就是就是分布式链路追踪（全链路追踪）
- Spring Cloud Sleuth 和 Zipkin ⼀起使用，把 Sleuth 的数据信息发送给 Zipkin 进⾏聚合，利⽤ Zipkin 储并展示数据



### 1.2 分布式链路追踪技术 - 方案

- Spring Cloud Sleuth + Twitter Zipkin
- 阿⾥巴巴：鹰眼
- ⼤众点评：CAT
- 美团：Mtrace
- 京东：Hydra
- 新浪：Watchman
- Apache Skywalking



### 1.3 分布式链路追踪技术 - 核心思想

#### （1）链路追踪 - 过程

- ⼀个请求 request-0 通过⽹关服务路由到下游的微服务-1
- 然后微服务-1调⽤微服务-2
- 拿到结果后再调⽤微服务-3
- 最后组合微服务-2 和 微服务-3 的结果 6，通过⽹关返回 response-7 给⽤户

![image-20211115183215220](image/image-20211115183215220.png)

#### （2）链路追踪 - 标识

- ⼀条链路通过TraceId唯⼀标识，span标识发起的请求信息，各 span 通过 parrentId 关联起来

- Trace：服务追踪的追踪单元是从客户发起请求（request）抵达被追踪系统的边界开始，到被追踪系统向客户返回响应（response）为⽌的过程

- Trace ID：为了实现请求跟踪，当请求发送到分布式系统的⼊⼝端点时，只需要服务跟踪框架为该请求创建⼀个唯⼀的跟踪标识Trace ID，同时在分布式系统内部流转的时候，框架失踪保持该唯⼀标识，直到返回给请求⽅

- Span 是⼀个⽇志数据结构，在⼀些特殊的时机点会记录了⼀些⽇志信息，⽐如有时间戳、spanId、TraceId，parentId等，Span中也抽象出了另外⼀个概念，叫做事件

```
核心事件如下
CS：client send/start           客户端/消费者发出⼀个请求，描述的是⼀个span开始
SR：server received/start       服务端/⽣产者接收请求    SR - CS = 请求发送的⽹络延迟
SS：server send/fifinish        服务端/⽣产者发送应答    SS - SR = 服务端消耗时间
CR：client received/fifinished  客户端/消费者接收应答    CR - SS = 回复需要的时间(响应的网络延迟)
```

- Span ID：为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过⼀个唯⼀标识Span ID来标记它的开始，具体过程以及结束。对每⼀个Span来说，它必须有开始和结束两个节点，通过记录开始Span和结束Span的时间戳，就能统计出该Span的时间延迟，除了时间戳记录之外，它还可以包含⼀些其他元数据，⽐如时间名称、请求信息等。每⼀个Span都会有⼀个唯⼀跟踪标识 Span ID，若⼲个有序的 span 就组成了⼀个trace



#### （3）链路追踪 - 标识关系

- ⼀个Trace由⼀个或者多个Span组成
- 每⼀个Span都有⼀个SpanId
- Span中会记录TraceId，同时还有⼀个叫做ParentId，指向了另外⼀个Span的SpanId，表明⽗⼦关系，其实本质表达了依赖关系



## 2、Spring Cloud Sleuth 链路追踪的使用

### 步骤1：引入依赖

- 每⼀个需要被追踪踪迹的微服务工程都

```xml
<!-- 链路追踪 Sleuth  -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
```



### 步骤2：修改 application.yml，添加日志级别

- 每⼀个微服务都 修改 application.yml 配置文件，添加日志级别
- 控制台可以观察到 Sleuth 输出的日志（全局 TraceId、SpanId 等）

```yaml
# 分布式链路追踪 Sleuth
logging:
  level:
    org.springframework.web.servlet.DispatcherServlet: debug
    org.springframework.cloud.sleuth: debug
```



## 3、Zipkin 展示追踪数据 

- Zipkin 包括 Zipkin Server 和 Zipkin Client 两部分，Zipkin Server是⼀个单独的服务，Zipkin Client就是具体的微服务



### 3.1 Zipkin Server 搭建

#### 步骤1：pom.xml

```xml
<dependencies>
    <!-- zipkin-server 的依赖坐标-->
    <dependency>
        <groupId>io.zipkin.java</groupId>
        <artifactId>zipkin-server</artifactId>
        <version>2.12.3</version>
        <exclusions>
            <!-- 排除掉log4j2的传递依赖，避免和springboot依赖的日志组件冲突 -->
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-log4j2</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <!--zipkin-server ui界面依赖坐标-->
    <dependency>
        <groupId>io.zipkin.java</groupId>
        <artifactId>zipkin-autoconfigure-ui</artifactId>
        <version>2.12.3</version>
    </dependency>

    <!-- Zipkin 持久化到 mysql-->
    <dependency>
        <groupId>io.zipkin.java</groupId>
        <artifactId>zipkin-autoconfigure-storage-mysql</artifactId>
        <version>2.12.3</version>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid-spring-boot-starter</artifactId>
        <version>1.1.10</version>
    </dependency>

    <!-- 操作数据库需要事务控制 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-tx</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
    </dependency>
</dependencies>
```



#### 步骤2：application.yml

```yaml
server:
  port: 9411

management:
  metrics:
    web:
      server:
        auto-time-requests: false # 关闭自动检测

spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/SpringCloud?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC
    username: root
    password: root
    druid:
      initialSize: 10
      minIdle: 10
      maxActive: 30
      maxWait: 50000

# Zipkin 持久化到 mysql
zipkin:
  storage:
    type: mysql
```



#### 步骤3：启动类 ZipkinServerApplication9411

```java
@SpringBootApplication
@EnableZipkinServer // 开启Zipkin 服务器功能
public class ZipkinServerApplication9411 {
    public static void main(String[] args) {
        SpringApplication.run(ZipkinServerApplication9411.class, args);
    }

    // Zipkin 持久化到 mysql（注入事务控制器）
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```



#### 步骤4：初始化数据库表

```mysql
CREATE TABLE IF NOT EXISTS zipkin_spans
(
    `trace_id_high`       BIGINT       NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
    `trace_id`            BIGINT       NOT NULL,
    `id`                  BIGINT       NOT NULL,
    `name`                VARCHAR(255) NOT NULL,
    `remote_service_name` VARCHAR(255),
    `parent_id`           BIGINT,
    `debug`               BIT(1),
    `start_ts`            BIGINT COMMENT 'Span.timestamp(): epoch micros used for endTs query and to implement TTL',
    `duration`            BIGINT COMMENT 'Span.duration(): micros used for minDuration and maxDuration query',
    PRIMARY KEY (`trace_id_high`, `trace_id`, `id`)
) ENGINE = InnoDB
  ROW_FORMAT = COMPRESSED
  CHARACTER SET = utf8
  COLLATE utf8_general_ci;
ALTER TABLE zipkin_spans
    ADD INDEX (`trace_id_high`,
               `trace_id`) COMMENT 'for getTracesByIds';

ALTER TABLE zipkin_spans ADD INDEX (`name`) COMMENT 'for getTraces and getSpanNames';
ALTER TABLE zipkin_spans ADD INDEX (`remote_service_name`) COMMENT 'for getTraces and getRemoteServiceNames';
ALTER TABLE zipkin_spans ADD INDEX (`start_ts`) COMMENT 'for getTraces ordering and range';


CREATE TABLE IF NOT EXISTS zipkin_annotations
(
    `trace_id_high`         BIGINT       NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
    `trace_id`              BIGINT       NOT NULL COMMENT 'coincides with zipkin_spans.trace_id',
    `span_id`               BIGINT       NOT NULL COMMENT 'coincides with zipkin_spans.id',
    `a_key`                 VARCHAR(255) NOT NULL COMMENT 'BinaryAnnotation.key or Annotation.value if type == -1',
    `a_value`               BLOB COMMENT 'BinaryAnnotation.value(), which must be smaller than 64KB',
    `a_type`                INT          NOT NULL COMMENT 'BinaryAnnotation.type() or -1 if Annotation',
    `a_timestamp`           BIGINT COMMENT 'Used to implement TTL;Annotation.timestamp or zipkin_spans.timestamp',
    `endpoint_ipv4`         INT COMMENT 'Null when Binary/Annotation.endpoint is null',
    `endpoint_ipv6`         BINARY(16) COMMENT 'Null when Binary/Annotation.endpoint is null, or no IPv6 address',
    `endpoint_port`         SMALLINT COMMENT 'Null when Binary/Annotation.endpoint is null',
    `endpoint_service_name` VARCHAR(255) COMMENT 'Null when Binary/Annotation.endpoint is null'
) ENGINE = InnoDB
  ROW_FORMAT = COMPRESSED
  CHARACTER SET = utf8
  COLLATE utf8_general_ci;

ALTER TABLE zipkin_annotations ADD UNIQUE KEY (`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT 'Ignore insert on duplicate';
ALTER TABLE zipkin_annotations ADD INDEX (`trace_id_high`, `trace_id`, `span_id`) COMMENT 'for joining with zipkin_spans';
ALTER TABLE zipkin_annotations ADD INDEX (`trace_id_high`, `trace_id`) COMMENT 'for getTraces/ByIds';
ALTER TABLE zipkin_annotations ADD INDEX (`endpoint_service_name`) COMMENT 'for getTraces and getServiceNames';
ALTER TABLE zipkin_annotations ADD INDEX (`a_type`) COMMENT 'for getTraces and autocomplete values';
ALTER TABLE zipkin_annotations ADD INDEX (`a_key`) COMMENT 'for getTraces and autocomplete values';
ALTER TABLE zipkin_annotations ADD INDEX (`trace_id`, `span_id`, `a_key`) COMMENT 'for dependencies job';


CREATE TABLE IF NOT EXISTS zipkin_dependencies
(
    `day`         DATE         NOT NULL,
    `parent`      VARCHAR(255) NOT NULL,
    `child`       VARCHAR(255) NOT NULL,
    `call_count`  BIGINT,
    `error_count` BIGINT,
    PRIMARY KEY (`day`, `parent`, `child`)
) ENGINE = InnoDB
  ROW_FORMAT = COMPRESSED
  CHARACTER SET = utf8
  COLLATE utf8_general_ci;
```



#### 步骤5：Zipkin Server UI 

- 访问地址：http://127.0.0.1:9411



### 3.2 Zipkin Client 搭建

- Zipkin Client 就是具体使用的微服务



#### 步骤1：pom.xml

```xml
<!-- Zipkin Client -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```



#### 步骤2：application.yml 

```yaml
spring:
  zipkin:
    # zipkin server 的请求地址
    base-url: http://127.0.0.1:9411
    sender:
      # web：客户端将踪迹日志数据通过网络请求的方式传送到服务端
      # kafka/rabbit：客户端将踪迹日志数据传递到 mq 进行中转
      type: web
  sleuth:
    sampler:
      # 采样率（1 代表 100% 全部采集）（默认0.1 代表 10% 的请求踪迹数据会被采集）
      # 生产环境下，请求量非常大，没有必要所有请求的踪迹数据都采集分析，对于网络包括server端压力都是比较大的，可以配置采样率采集一定比例的请求的踪迹数据进行分析即可
      probability: 1
```



#### 步骤3：测试接口

- http://localhost:9002/autodeliver/checkState3/1545132



# 第九章 统一认证方案 - Spring Cloud OAuth2 + JWT

## 1、微服务架构下统一认证思路

### （1）基于Session的认证方式

- 在分布式的环境下，基于 session 的认证会出现⼀个问题，每个应⽤服务都需要在session中存储⽤户身份信息，通过负载均衡将本地的请求分配到另⼀个应⽤服务。并将session信息带过去，否则会重新认证。
- 这里可以使⽤Session共享、Session黏贴等⽅案
- Session⽅案也有缺点，⽐如基于cookie，移动端不能有效使⽤等



### （2）基于token的认证⽅式

- 基于token的认证⽅式，服务端不⽤存储认证数据，易维护扩展性强， 客户端可以把 token 存在任意地⽅，并且可以实现web和app统⼀认证机制
- 其缺点也很明显，token由于⾃包含信息，因此⼀般数据量较⼤，⽽且每次请求都需要传递，因此⽐较占带宽。另外，token的签名验签操作也会给cpu带来额外的处理负担。



## 2、OAuth2

### 2.1 OAuth2 简介

- OAuth（开放授权）是⼀个开放协议/标准，允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。
- OAuth2是OAuth协议的延续版本，但不向后兼容OAuth1即完全废⽌了OAuth1。



### 2.2 OAuth2 协议流程

- 资源所有者（Resource Owner）：可以理解为⽤户⾃⼰
- 客户端（Client）：想登陆的第三方⽹站或应⽤
- 认证服务器（Authorization Server）：可以理解为微信或者QQ
- 资源服务器（Resource Server）：可以理解为微信或者QQ

![image-20211116132544222](image/image-20211116132544222.png)

### 2.3 OAuth2 使用场景

#### （1）第三方授权登录的场景

- 经常登录⼀些⽹站或者应⽤的时候，可以选择使⽤第三⽅授权登录的⽅式
- ⽐如：微信授权登录、QQ授权登录、微博授权登录等，这是典型的 OAuth2 使⽤场景



#### （2）单点登录的场景

- 如果项⽬中有很多微服务或者公司内部有很多服务，可以专⻔做⼀个认证中⼼（充当认证平台⻆⾊），所有的服务都要到这个认证中⼼做认证，只做⼀次登录，就可以在多个授权范围内的服务中⾃由串⾏。



### 2.3 OAuth2 颁发 Token 的授权方式 

https://blog.csdn.net/lixiang987654321/article/details/83381494

#### （1）授权码（authorization-code） 

- 使⽤到了回调地址，是最复杂的授权⽅式
- 微博、微信、QQ等第三⽅登录就是这种模式



#### （2）密码式（password）

- 提供⽤户名 + 密码换取token令牌
- 接⼝对接中常使⽤password密码模式



#### （3）隐藏式（implicit）



#### （4）客户端凭证（client credentials）



## 3、Spring Cloud OAuth2

### 3.1 Spring Cloud OAuth2 简介

- Spring Cloud OAuth2 是 Spring Cloud 体系对OAuth2协议的实现
- 可以⽤来做多个微服务的统⼀认证（验证身份合法性）授权（验证权限）
- 通过向OAuth2服务（统⼀认证授权服务）发送某个类型的 grant_type 进⾏集中认证和授权，从⽽获得access_token（访问令牌），⽽这个token是受其他微服务信任的。
- 使⽤OAuth2解决问题的本质是，引⼊了⼀个认证授权层，认证授权层连接了资源的拥有者，在授权层⾥⾯，资源的拥有者可以给第三⽅应⽤授权去访问某些受保护资源



### 3.2 Spring Cloud OAuth2 搭建思路

- 在统⼀认证的场景中，Resource Server 是各种受保护的微服务，
- 微服务中的各种API访问接⼝就是资源
- 发起http请求的浏览器就是 Client 客户端（对应为第三⽅应⽤）

![image-20211116140239069](image/image-20211116140239069.png)



## 4、JWT

### 4.1 JWT 简介

- JSON Web Token（JWT）是⼀个开放的⾏业标准（RFC 7519）
- 它定义了⼀种简介的、⾃包含的协议格式，⽤于在通信双⽅传递json对象，传递的信息经过数字签名可以被验证和信任
- JWT 可以使⽤ HMAC 算法或使⽤ RSA （非对称加密）的公钥/私钥对来签名，防⽌被篡改



### 4.2 JWT 令牌结构

- JWT令牌由三部分组成，每部分中间使⽤点（.）分隔，⽐如：xxxxx.yyyyy.zzzzz

#### （1）Header

- 头部包括令牌的类型（即JWT）及使⽤的哈希算法（如HMAC SHA256 或 RSA 非对称加密 ）
- 头部内容使⽤ Base64Url 编码，得到⼀个字符串就是 JWT 令牌的第⼀部分

```json
{
 "alg": "HS256",
 "typ": "JWT"
}
```



#### （2）Payload

- Payload 负载，内容也是⼀个json对象，它是存放有效信息的地⽅，它可以存放 jwt 提供的现成字段
- 比如：iss（签发者）,exp（过期时间戳）, sub（⾯向的⽤户）等，也可⾃定义字段。
- 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容
- 最后将第⼆部分负载使⽤ Base64Url 编码，得到⼀个字符串就是 JWT 令牌的第⼆部分

```json
{
 "sub": "1234567890",
 "name": "John Doe",
 "iat": 1516239022
}
```



#### （3）Signature

- Signature 签名，此部分⽤于防⽌jwt内容被篡改。
- 这个部分使⽤ base64url 将前两部分进⾏编码，编码后使⽤点（.）连接组成字符串，最后使⽤header中声明签名算法进⾏签名

```json
// base64UrlEncode(header)：jwt 令牌的第⼀部分
// base64UrlEncode(payload)：jwt 令牌的第⼆部分
// secret：签名所使用的密钥
HMACSHA256(
 base64UrlEncode(header) + "." +
 base64UrlEncode(payload),
 secret)
```



### 4.3 JWT 解密

- 地址：https://jwt.io/

![image-20211116192655946](image/image-20211116192655946.png)



## 5、搭建认证服务器（Authorization Server）

- 认证服务器（Authorization Server），负责颁发 token
- cloud-oauth2-server-9999



### 步骤1：pom.xml

```xml
<dependencies>
    <dependency>
        <groupId>com.loto</groupId>
        <artifactId>resume-service-common</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>

    <!-- Eureka Client -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <!-- spring cloud oauth2 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-oauth2</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.security.oauth.boot</groupId>
                <artifactId>spring-security-oauth2-autoconfigure</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <!-- oauth2 autoconfigure -->
    <dependency>
        <groupId>org.springframework.security.oauth.boot</groupId>
        <artifactId>spring-security-oauth2-autoconfigure</artifactId>
        <version>2.1.11.RELEASE</version>
    </dependency>

    <!-- security对oauth2的支持 -->
    <dependency>
        <groupId>org.springframework.security.oauth</groupId>
        <artifactId>spring-security-oauth2</artifactId>
        <version>2.3.4.RELEASE</version>
    </dependency>

    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
</dependencies>
```



### 步骤2：application.yml

```yaml
server:
  port: 9999

spring:
  application:
    name: cloud-oauth2-server
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/SpringCloud?useUnicode=true&characterEncoding=utf8&serverTimezone=UTC
    username: root
    password: root
    druid:
      initialSize: 10
      minIdle: 10
      maxActive: 30
      maxWait: 50000

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@
```



### 步骤3：启动类 

```java
@SpringBootApplication
@EnableDiscoveryClient
@EntityScan("com.loto.pojo")
public class Oauth2ServerApplication9999 {
    public static void main(String[] args) {
        SpringApplication.run(Oauth2ServerApplication9999.class, args);
    }
}
```



### 步骤4：OauthServerConfig（Oauth2 server 认证服务器配置）

- OauthServerConfig.java

```java
/**
 * Oauth2 server的配置类（需要继承特定的父类 AuthorizationServerConfigurerAdapter）
 */
@Configuration
@EnableAuthorizationServer  // 开启认证服务器功能
public class OauthServerConfig extends AuthorizationServerConfigurerAdapter {
    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private TDAccessTokenConvertor tdAccessTokenConvertor;

    // jwt签名密钥
    private String sign_key = "td123";

    /**
     * 配置令牌端点的安全约束，接口访问权限 ------- 认证服务器最终是以api接口的方式对外提供服务（校验合法性并生成令牌、校验令牌等）
     */
    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        super.configure(security);

        // 相当于打开 endpoints 访问接口的开关
        security
                .allowFormAuthenticationForClients()  // 允许客户端表单认证
                .tokenKeyAccess("permitAll()")        // 开启端口 /oauth/token_key 访问权限（允许）
                .checkTokenAccess("permitAll()");     // 开启端口 /oauth/check_token 访问权限（允许）
    }

    /**
     * 用来配置客户端详情服务（ClientDetailsService），客户端详情信息在这初始化，可以把客户端详情信息写死或是通过数据库来存储调取详情信息
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        super.configure(clients);

        // 方式1：从内存中加载客户端详情
        //clients.inMemory()
        //        .withClient("client_td")     // 添加一个client配置，指定其 client_id
        //        .secret("abcxyz")                   // 指定客户端的密码/安全码
        //        .resourceIds("autodeliver")         // 指定客户端所能访问资源id清单，此处的资源id是需要在具体的资源服务器上也配置一样
        //        .authorizedGrantTypes("password", "refresh_token") // 认证类型/令牌颁发模式，可以配置多个在这里，但是不一定都用，具体使用哪种方式颁发token，需要客户端调用的时候传递参数指定
        //        .scopes("all");                     // 客户端的权限范围，配置为 all 表示全部

        // 方式2：从数据库中加载客户端详情
        clients.withClientDetails(createJdbcClientDetailsService());
    }

    @Autowired
    private DataSource dataSource;

    @Bean
    public JdbcClientDetailsService createJdbcClientDetailsService() {
        JdbcClientDetailsService jdbcClientDetailsService = new JdbcClientDetailsService(dataSource);
        return jdbcClientDetailsService;
    }

    /**
     * 用来配置令牌（token）的访问端点和令牌服务(token services)
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        super.configure(endpoints);

        endpoints
                .tokenStore(tokenStore())    // 指定 token 的存储方法
                .tokenServices(authorizationServerTokenServices())   // token服务的一个描述（生成细节的描述），比如有效时间多少等
                .authenticationManager(authenticationManager)        // 指定认证管理器，随后注入一个到当前类使用即可
                .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST);
    }

    /**
     * 用于创建 tokenStore 对象（令牌存储对象），token以什么形式存储
     */
    public TokenStore tokenStore() {
        // 使用内存存储 token
        //return new InMemoryTokenStore();

        // 使用 jwt 令牌
        return new JwtTokenStore(jwtAccessTokenConverter());
    }

    /**
     * 获取一个 token 服务对象（该对象描述了 token 有效期等信息）
     */
    public AuthorizationServerTokenServices authorizationServerTokenServices() {
        // 使用默认实现
        DefaultTokenServices defaultTokenServices = new DefaultTokenServices();
        defaultTokenServices.setSupportRefreshToken(true); // 是否开启令牌刷新
        defaultTokenServices.setTokenStore(tokenStore());

        // 针对 jwt 令牌的添加
        defaultTokenServices.setTokenEnhancer(jwtAccessTokenConverter());

        // 设置令牌有效时间（一般设置为2个小时）
        // access_token 就是请求资源需要携带的令牌
        defaultTokenServices.setAccessTokenValiditySeconds(7200);

        // 设置刷新令牌的有效时间（此处设置为 3 天）
        defaultTokenServices.setRefreshTokenValiditySeconds(259200);

        return defaultTokenServices;
    }

    /**
     * 返回 jwt令牌转换器（帮助我们生成jwt令牌的），在这里，可以把签名密钥传递进去给转换器对象
     */
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        jwtAccessTokenConverter.setSigningKey(sign_key);               // 签名密钥
        jwtAccessTokenConverter.setVerifier(new MacSigner(sign_key));  // 验证时使用的密钥，和签名密钥保持一致
        jwtAccessTokenConverter.setAccessTokenConverter(tdAccessTokenConvertor);

        return jwtAccessTokenConverter;
    }
}
```



### 步骤5：SecurityConfig（处理用户名和密码的校验等事宜）

- SecurityConfig.java

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JdbcUserDetailsService jdbcUserDetailsService;

    /**
     * 注入认证管理器对象到容器
     */
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    /**
     * 密码编码对象（密码不进行加密处理）
     *
     * @return
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }

    /**
     * 处理用户名和密码验证事宜<p>
     * （1）客户端传递 username 和 password 参数到认证服务器<p>
     * （2）一般来说，username 和 password 会存储在数据库中的用户表中<p>
     * （3）根据用户表中数据，验证当前传递过来的用户信息的合法性
     */
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 把用户信息配置在内存中
        // 实例化一个用户对象（相当于数据表中的一条用户记录）
        //UserDetails user = new User("admin", "123456", new ArrayList<>());
        //auth.inMemoryAuthentication().withUser(user).passwordEncoder(passwordEncoder);

        // 把用户信息配置在数据库中
        auth.userDetailsService(jdbcUserDetailsService).passwordEncoder(passwordEncoder);
    }
}
```



### 步骤6：TDAccessTokenConvertor（设置 JWT 扩展信息）

- TDAccessTokenConvertor.java

```java
@Component
public class TDAccessTokenConvertor extends DefaultAccessTokenConverter {
    @Override
    public Map<String, ?> convertAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {
        // 获取到request对象
        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.getRequestAttributes())).getRequest();

        // 设置 JWT 扩展信息
        // 获取客户端ip（注意：如果是经过代理之后到达当前服务的话，那么这种方式获取的并不是真实的浏览器客户端ip）
        String remoteAddr = request.getRemoteAddr();
        Map<String, String> stringMap = (Map<String, String>) super.convertAccessToken(token, authentication);
        stringMap.put("clientIp", remoteAddr);

        return stringMap;
    }
}
```



### 步骤7：根据 username 查询出该用户的所有信息

- JdbcUserDetailsService.java

```java
@Service
public class JdbcUserDetailsService implements UserDetailsService {
    @Autowired
    private UsersRepository usersRepository;

    /**
     * 根据 username 查询出该用户的所有信息，封装成 UserDetails 类型的对象返回，至于密码，框架会自动匹配
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Users users = usersRepository.findByUsername(username);
        return new User(users.getUsername(), users.getPassword(), new ArrayList<>());
    }
}
```



### 步骤8：Jpa 数据库查询

- UsersRepository .java

```java
public interface UsersRepository extends JpaRepository<Users,Long> {
    Users findByUsername(String username);
}
```



### 步骤9：测试

#### （1）获取 Token

- http://localhost:9999/oauth/token?client_id=client_td123&client_secret=abcxyz&grant_type=password&username=admin&password=123456

- 参数描述

![image-20211116185130852](image/image-20211116185130852.png)

- 返回结果

```json
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzcwNjcwNDUsImp0aSI6IjcwYzc0MmE3LTllZjItNDdmZi1hN2FkLWFmN2U2MmYwZmEyOSIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.jqsWJRqev_VTUeEwef_4bx5fm973Empsr3o1I-SRo4w",
    "token_type": "bearer",
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiYXRpIjoiNzBjNzQyYTctOWVmMi00N2ZmLWE3YWQtYWY3ZTYyZjBmYTI5IiwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzczMTkwNDUsImp0aSI6ImYyM2ZhNTZjLTRiYzktNDYwYy05NmYzLWFkN2JhYzcxMWZlMiIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.GqYCSEbrDeG8omIeyDmOIfXtIEF9utxxf-ihnVOB55g",
    "expires_in": 7199,
    "scope": "all",
    "jti": "70c742a7-9ef2-47ff-a7ad-af7e62f0fa29"
}
```



#### （2）校验 Token

- http://localhost:9999/oauth/check_token?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzcwNjcwNDUsImp0aSI6IjcwYzc0MmE3LTllZjItNDdmZi1hN2FkLWFmN2U2MmYwZmEyOSIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.jqsWJRqev_VTUeEwef_4bx5fm973Empsr3o1I-SRo4w

- 返回结果

```json
{
    "aud": [
        "resume",
        "autodeliver"
    ],
    "user_name": "admin",
    "scope": [
        "all"
    ],
    "clientIp": "0:0:0:0:0:0:0:1",
    "active": true,
    "exp": 1637067045,
    "jti": "70c742a7-9ef2-47ff-a7ad-af7e62f0fa29",
    "client_id": "client_td123"
}
```



#### （3）刷新 Token

- http://localhost:9999/oauth/token?client_id=client_td123&client_secret=abcxyz&grant_type=refresh_token&refresh_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiYXRpIjoiNzBjNzQyYTctOWVmMi00N2ZmLWE3YWQtYWY3ZTYyZjBmYTI5IiwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzczMTkwNDUsImp0aSI6ImYyM2ZhNTZjLTRiYzktNDYwYy05NmYzLWFkN2JhYzcxMWZlMiIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.GqYCSEbrDeG8omIeyDmOIfXtIEF9utxxf-ihnVOB55g

- 返回结果

```json
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzcwNjcyMzIsImp0aSI6ImIyNjY1YjQyLTFmMzgtNDlkOC05NDI5LTZkZTVhNTY3OTcxNCIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.cK9cSQYLxRvCjvzanWsV9pq3-hErN37Ff52QQFWpsnI",
    "token_type": "bearer",
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiYXRpIjoiYjI2NjViNDItMWYzOC00OWQ4LTk0MjktNmRlNWE1Njc5NzE0IiwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzczMTkwNDUsImp0aSI6ImYyM2ZhNTZjLTRiYzktNDYwYy05NmYzLWFkN2JhYzcxMWZlMiIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.G_VfezdB63zEQc7F1BRfikYlZS4QlGhx1nprcNMW_9g",
    "expires_in": 7199,
    "scope": "all",
    "jti": "b2665b42-1f38-49d8-9429-6de5a5679714"
}
```



## 6、搭建资源服务器

- resume-service-autodeliver-oauth2-8093



### 步骤1：pom.xml

```xml
<dependencies>
    <!-- eureka client 客户端依赖引入-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <!-- spring cloud oauth2依赖 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-oauth2</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.security.oauth.boot</groupId>
                <artifactId>spring-security-oauth2-autoconfigure</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <!-- oauth2 autoconfigure -->
    <dependency>
        <groupId>org.springframework.security.oauth.boot</groupId>
        <artifactId>spring-security-oauth2-autoconfigure</artifactId>
        <version>2.1.11.RELEASE</version>
    </dependency>

    <!-- 引入security对oauth2的支持 -->
    <dependency>
        <groupId>org.springframework.security.oauth</groupId>
        <artifactId>spring-security-oauth2</artifactId>
        <version>2.3.4.RELEASE</version>
    </dependency>
</dependencies>
```



### 步骤2：application.yml

```yaml
server:
  port: 8093

spring:
  application:
    name: resume-service-autodeliver

# springboot 中暴露健康检查等断点接口
management:
  endpoints:
    web:
      exposure:
        include: "*"
  # 暴露健康接口的细节
  endpoint:
    health:
      show-details: always

# 将服务提供者注册到 Eureka 服务中心
eureka:
  client:
    service-url:
      # 注册到单实例（非集群模式），就写一个就可以
      # 注册到集群，把多个 Eureka server 地址使用逗号连接起来即可
      defaultZone: http://CloudEurekaServerA:8761/eureka,http://CloudEurekaServerB:8762/eureka
  instance:
    # 服务实例中显示 ip，而不是显示主机名（为了兼容老的 eureka 版本）
    prefer-ip-address: true
    # 自定义实例显示格式（加上版本号，便于多版本管理）
    instance-id: ${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@

# 针对的被调用方微服务名称 resume-service-resume（不加 22 行这个服务名称，就是全局生效）
resume-service-resume:
  ribbon:
    # 负载策略调整：使用轮询
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
```



### 步骤3：启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class AutodeliverApplication8093 {
    public static void main(String[] args) {
        SpringApplication.run(AutodeliverApplication8093.class, args);
    }

    // 使用 RestTemplate 模板对象进行远程调用
    @Bean
    @LoadBalanced // Ribbon 负载均衡
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
```



### 步骤4：ResourceServerConfig（资源服务器配置）

```java
@Configuration
@EnableResourceServer  // 开启资源服务器功能
@EnableWebSecurity     // 开启web访问安全
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {
    // jwt 签名密钥
    private String sign_key = "td123";

    @Autowired
    private TDAccessTokenConvertor tdAccessTokenConvertor;

    /**
     * 用于定义资源服务器向远程认证服务器发起请求，进行token校验等事宜
     */
    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
        //// 设置当前资源服务的资源id
        //resources.resourceId("autodeliver");
        //
        //// 定义 token 服务对象（用于 token 校验）
        //RemoteTokenServices remoteTokenServices = new RemoteTokenServices();
        //
        //// 校验端点/接口设置
        //remoteTokenServices.setCheckTokenEndpointUrl("http://localhost:9999/oauth/check_token");
        //
        //// 携带客户端id和客户端安全码
        //remoteTokenServices.setClientId("client_td");
        //remoteTokenServices.setClientSecret("abcxyz");
        //
        //resources.tokenServices(remoteTokenServices);

        // jwt 令牌改造
        resources.resourceId("autodeliver").tokenStore(tokenStore()).stateless(true);// 无状态设置
    }

    /**
     * 用于创建 tokenStore 对象（令牌存储对象），token以什么形式存储
     */
    public TokenStore tokenStore() {
        // 使用内存存储 token
        //return new InMemoryTokenStore();

        // 使用 jwt 令牌
        return new JwtTokenStore(jwtAccessTokenConverter());
    }

    /**
     * 返回 jwt令牌转换器（帮助我们生成jwt令牌的），在这里，可以把签名密钥传递进去给转换器对象
     */
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        jwtAccessTokenConverter.setSigningKey(sign_key);               // 签名密钥
        jwtAccessTokenConverter.setVerifier(new MacSigner(sign_key));  // 验证时使用的密钥，和签名密钥保持一致
        jwtAccessTokenConverter.setAccessTokenConverter(tdAccessTokenConvertor);

        return jwtAccessTokenConverter;
    }

    /**
     * 场景：一个服务中可能有很多资源（API接口）<p>
     * 某一些API接口，需要先认证，才能访问<p>
     * 某一些API接口，压根就不需要认证，本来就是对外开放的接口<p>
     * 所以需要对不同特点的接口区分对待（在当前configure方法中完成），设置是否需要经过认证
     */
    @Override
    public void configure(HttpSecurity http) throws Exception {
        http.sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)  // 设置session的创建策略（IF_REQUIRED 根据需要创建）
                .and()
                .authorizeRequests()
                .antMatchers("/autodeliver/**").authenticated()  // autodeliver 为前缀的请求需要认证
                .antMatchers("/demo/**").authenticated()         // demo 为前缀的请求需要认证
                .anyRequest().permitAll();  //  其他请求不认证
    }
}
```



### 步骤5：TDAccessTokenConvertor（获取 JWT 令牌中的扩展信息）

```java
@Component
public class TDAccessTokenConvertor extends DefaultAccessTokenConverter {
    // 资源服务器获取 JWT 令牌中的扩展信息
    @Override
    public OAuth2Authentication extractAuthentication(Map<String, ?> map) {
        OAuth2Authentication oAuth2Authentication = super.extractAuthentication(map);

        // 将map放入认证对象中，认证对象在 controller 中可以拿到
        oAuth2Authentication.setDetails(map);
        return oAuth2Authentication;
    }
}
```



### 步骤6：AutodeliverController

```java
@RestController
@RequestMapping("/autodeliver")
public class AutodeliverController {
    // RestTemplate 模板对象（Rest 风格的远程服务调用）
    @Autowired
    private RestTemplate restTemplate;

    //http://localhost:8093/autodeliver/checkState3/1545132
    /**
     * 使用 Ribbon 负载均衡
     */
    @GetMapping("/checkState3/{userId}")
    public Integer findResumeOpenState3(@PathVariable Long userId) {
        // 指定服务名
        String url = "http://resume-service-resume/resume/openstate/" + userId;
        Integer forObject = restTemplate.getForObject(url, Integer.class);
        return forObject;
    }
}
```



### 步骤7：DemoController

```java
@RestController
@RequestMapping("/demo")
public class DemoController {
    @GetMapping("/test")
    public String findResumeOpenState() {
        Object details = SecurityContextHolder.getContext().getAuthentication().getDetails();
        return "demo/test!";
    }
}
```



### 步骤8：OthersController

```java
@RestController
@RequestMapping("/others")
public class OthersController {
    @GetMapping("/test")
    public String findResumeOpenState() {
        return "others/test!";
    }
}
```



### 步骤9：测试

#### （1）资源服务器 - 直接访问

- http://localhost:8093/autodeliver/checkState3/1545132
- http://localhost:8093/demo/test
- http://localhost:8093/others/test



#### （2）资源服务器 - 使用 JWT 令牌访问

- http://localhost:8093/autodeliver/checkState3/1545132?access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzcwNjcyMzIsImp0aSI6ImIyNjY1YjQyLTFmMzgtNDlkOC05NDI5LTZkZTVhNTY3OTcxNCIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.cK9cSQYLxRvCjvzanWsV9pq3-hErN37Ff52QQFWpsnI
- http://localhost:8093/demo/test?access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzdW1lIiwiYXV0b2RlbGl2ZXIiXSwidXNlcl9uYW1lIjoiYWRtaW4iLCJzY29wZSI6WyJhbGwiXSwiY2xpZW50SXAiOiIwOjA6MDowOjA6MDowOjEiLCJleHAiOjE2MzcwNjcyMzIsImp0aSI6ImIyNjY1YjQyLTFmMzgtNDlkOC05NDI5LTZkZTVhNTY3OTcxNCIsImNsaWVudF9pZCI6ImNsaWVudF90ZDEyMyJ9.cK9cSQYLxRvCjvzanWsV9pq3-hErN37Ff52QQFWpsnI



## 7、认证服务器端 AuthorizationServerConfigurerAdapter.java 详解

### 7.1 方法 configure(ClientDetailsServiceConfigurer clients)

- ⽤来配置客户端详情服务（ClientDetailsService）
- 客户端详情信息在 这⾥进⾏初始化，可以把客户端详情信息写死在这⾥或者是通过数据库来存储调取详情信息



### 7.2 方法 configure(AuthorizationServerEndpointsConfigurer endpoints)

- ⽤来配置令牌（token）的访问端点和令牌服务(token services)

```java
@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
    super.configure(endpoints);

    endpoints
            .tokenStore(tokenStore())    // 指定 token 的存储方法
            .tokenServices(authorizationServerTokenServices())   // token服务的一个描述（生成细节的描述），比如有效时间多少等
            .authenticationManager(authenticationManager)        // 指定认证管理器，随后注入一个到当前类使用即可
            .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST);
}


/**
 * 用于创建 tokenStore 对象（令牌存储对象），token以什么形式存储
 */
public TokenStore tokenStore() {
  // 使用内存存储 token
  //return new InMemoryTokenStore();

  // 使用 jwt 令牌
  return new JwtTokenStore(jwtAccessTokenConverter());
}
```



- 关于 TokenStore

```
（1）InMemoryTokenStore
- 默认采⽤
- 它可以完美的⼯作在单服务器上（即访问并发量 压⼒不⼤的情况下，并且它在失败的时候不会进⾏备份），⼤多数的项⽬都可以使⽤这个版本的实现来进⾏ 尝试，你可以在开发的时候使⽤它来进⾏管理，因为不会被保存到磁盘中，所以更易于调试。

（2）JdbcTokenStore
- 这是⼀个基于JDBC的实现版本，令牌会被保存进关系型数据库
- 使⽤这个版本的实现时，可以在不同的服务器之间共享令牌信息，使⽤这个版本的时候请注意把"spring-jdbc"这个依赖加⼊到 classpath 中

（3）JwtTokenStore
- 这个版本的全称是 JSON Web Token（JWT）
- 它可以把令牌相关的数据进⾏编码（因此对于后端服务来说，它不需要进⾏存储，这将是⼀个重⼤优势）
- 缺点就是这个令牌占⽤的空间会⽐较⼤，如果加⼊了⽐较多⽤户凭证信息，JwtTokenStore 不会保存任何数据
```



### 7.3 方法 configure(AuthorizationServerSecurityConfigurer oauthServer)

- ⽤来配置令牌端点的安全约束

