> 当前位置：【Java】07_JavaWeb_Framework（开源框架） -> 7.5_SpringBoot



# 第一章 SpringBoot 概述

## 0、约定优于配置

```
概念：约定优于配置(Convention over Configuration)，又称按约定编程，是一种软件设计规范。

本质上是对系统、类库或框架中一些东西假定一个大众化合理的默认值(缺省值)。

例如在模型中存在一个名为 User 的类，那么对应到数据库会存在一个名为 user 的表，此时无需做额外的配置，只有在偏离这个约定时才需要做相关的配置（例如你想将表名命名为 t_user 等非 user 时才需要写关于这个名字的配置）。

如果所用工具的约定与你的期待相符，便可省去配置；反之，你可以配置来达到你所期待的方式。

简单来说就是假如你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。

好处：大大减少了配置项
```



## 1、SpringBoot 简介

### 1.1 什么是SpringBoot

- 官网：https://spring.io/projects/spring-boot
- GitHub：https://github.com/spring-projects/spring-boot

```
- 通过Spring Boot，可以轻松地创建独立的，基于生产级别的基于Spring的应用程序，并且可以“运行”它们
- 其实 Spring Boot 的设计是为了让你尽可能快的启动 Spring 应用程序并且尽可能减少你的配置文件

- SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框
架
- 它基于Spring4.0设计
```



### 1.2 SpringBoot 发展

| 年份 | Spring 版本                   | SpringBoot 版本 |
| ---- | ----------------------------- | --------------- |
| 2004 | Spring 1.0                    |                 |
| 2006 | Spring 2.0                    |                 |
| 2007 | Spring 2.5                    |                 |
| 2009 | Spring 3.0（Servlet 3.0规范） |                 |
| 2013 | Spring 4.0（Servlet 3.1规范） |                 |
| 2014 |                               | SpringBoot 1.0  |
| 2017 | Spring 5.0                    |                 |
| 2018 |                               | SpringBoot 2.0  |



### 1.3 SpringBoot 主要特性 

#### （1）SpringBoot Starter

- 将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的 Maven 或 Gradle 构建中；

#### （2）使编码变得简单

- SpringBoot 采用  JavaConfig 的方式对 Spring 进行配置，并且提供了大量的注解，极大的提高了工作效率。

```
- 在类名上添加注解 @Configuration
```

#### （3）自动配置

- SpringBoot 的自动配置特性利用了 Spring 对条件化配置的支持，合理地推测应用所需的 bean 并自动化配置他们；

```
- SpringBoot 在启动的过程中，会自动的将一些配置类的 bean 进行创建，并且添加到 ioc 容器中
```

#### （4）使部署变得简单

- SpringBoot 内置了三种 Servlet 容器（Tomcat、Jetty、undertow），只需要一个 Java 的运行环境就可以跑 SpringBoot 的项目了，SpringBoot 的项目可以打成一个jar包。



## 2、SpringBoot 案例实现 

### 步骤 1：创建方式

#### 方式 1：使用 idea 创建

#### 方式 2：在 SpringBoot 官网创建

- https://start.spring.io/



### 步骤 2：界面介绍

![image-20210812230100352](image/image-20210812230100352.png)



## 3、SpringBoot 全局配置文件

### 3.1 全局配置文件优先级

- Spring Boot 使用一个 application.properties 或者 application.yaml 的文件作为全局配置文件

```shell
优先级从高到低，以下四个目录的文件都会被加载，互补设置
- 先去 项目根目录 找 config 文件夹下找配置文件（项目名/config/xxx，如果是多级 maven，要配置到顶级父工程下）
- 再去 根目录 下找配置文件（项目名/xxx，如果是多级 maven，要配置到顶级父工程下）
- 去 resources 下找 cofnig 文件夹下找配置文件（项目名/src/main/resources/config/xxx）
- 去 resources 下找配置文件（项目名/src/main/resources/xxx）
```

- 其他情况

```shell
- 如果同一个目录下，有 application.yml 也有 application.properties，默认先读取 application.properties

- 如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的

- 创建 SpringBoot 项目时，一般的配置文件放置在项目的 resources 目录下
```

- 使用命令指定其他位置配置文件

```shell
- 如果配置文件名字不叫 application.properties 或者 application.yml，可以通过以下参数来指定
配置文件的名字，myproject是配置文件名
java -jar myproject.jar --spring.config.name=myproject

- 也可以指定其他位置的配置文件来生效
java -jar run-0.0.1-SNAPSHOT.jar -- spring.config.location=D:/application.properties
```





## 4、属性注入





# 第二章 SpringBoot 源码剖析



# 第三章 SpringBoot 日志框架



# 第四章 SpringBoot 数据访问



# 第五章 SpringBoot 缓存使用



# 第六章 SpringBoot 项目部署

## 1、热部署

### 1.1 使用步骤

#### 步骤 1：pom.xml 添加依赖

```xml
<!-- 引入热部署依赖 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-devtools</artifactId>
</dependency>
```

#### 步骤 2：排除资源

```properties
# 默认情况下，改变资源文件 /META-INF/maven ， /META-INF/resources ， /resources ， /static ， /public ， 或 /templates 不触发重新启动

# 在 application.properties 中设置不触发重新启动的目录
spring.devtools.restart.exclude=static/**,public/**
```

#### 步骤 3： IDEA 工具热部署设置

- File -> Settings -> Compiler -> 勾选 “Build project automatically” 选项将项目设置为自动编译

- 使用组合快捷键 “Ctrl+Shift+Alt+/” 打开 Maintenance 选项框，选中并打开 Registry 页面，列表中找到“compiler.automake.allow.when.app.running”，将该选项后的Value值勾选，用于指定 IDEA 工具在程序运行过程中自动编译



### 1.2 热部署原理

- 原理：引入了插件后，在编辑器上启动项目，插件会监控 classpath 的资源变化，当改动相关的代码， classpath 有变化后，编辑器会自动触发编译替换掉历史的 .class 文件，重启 srpring-boot 项目

  

- 插件重启快速的原因：对类加载采用了两种类加载器

```java
- 对于第三方 jar 包采用 base-classloader 来加载
- 对于开发人员自己开发的代码则使用 restartClassLoader 来进行加载
  
- 这使得热部署比停掉服务重启要快的多，因为使用插件 devtools 只是重启开发人员编写的代码部分
```



- 验证

```java
package com.loto.springboot.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.DispatcherServlet;

@Component
public class Devtools implements InitializingBean {
    private static final Logger log = LoggerFactory.getLogger(Devtools.class);

    /**
     *  验证热部署：对类加载采用了两种类加载器
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        log.info("guava-jar ClassLoader: " + DispatcherServlet.class.getClassLoader().toString());
        log.info("Devtools ClassLoader: " + this.getClass().getClassLoader().toString());
    }
}
```

- 先去除spring-boot-devtools插件，跑下工程，可以看到，DispatcherServlet（第三方jar包）和Devtools（自己编写的类）使用的都是 AppClassLoader 加载的。

```properties
c.l.s.c.Devtools : guava-jar ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17

c.l.s.c.Devtools : Devtools ClassLoader : jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17
```

- 加上插件，然后执行下代码，发现第三方的 jar 包的类加载器确实是使用的系统的类加载器，而自己写的代码的类加载器为 RestartClassLoader，并且每次重启，类加载器的实例都会改变。

```properties
c.l.s.c.Devtools : guava-jar ClassLoader: jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17

c.l.s.c.Devtools : Devtools ClassLoader : org.springframework.boot.devtools.restart.classloader.RestartClassLoader@65156812
```



# 第七章 SpringBoot 项目监控





# 其他问题

## 1、解决页面输出中文乱码

```properties
# 解决方法一：在某个具体方法上
@RequestMapping(produces = "application/json; charset=utf-8")

# 解决方法二：在 application.properties 中配置
# 设置响应为utf-8 
spring.http.encoding.force-response=true
```





