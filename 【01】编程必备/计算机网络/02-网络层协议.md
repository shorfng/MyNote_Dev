> 当前位置：【01】编程必备 -> 计算机网络 -> 02-网络层协议



# 第一章 IP 协议

## 1、什么是 IP 协议？

- IP 协议（Internet Protocol）是一个处于垄断地位的网络层协议
- 在网络层，IP 协议几乎一统天下



## 2、IP 协议分类

- IP 协议目前主要有两个版本 IPv4 和 IPv6

![image-20210818083900850](image/image-20210818083900850.png)



## 3、IP 协议不保证可靠性

- IP 协议并不负责数据的可靠性，自身不能保证可靠性

```
- 传输数据时，数据被切分成一个个数据封包。
- IP 协议上层的传输层协议会对数据进行一次拆分，IP 协议还会进一步进行拆分。
- 进行两次拆分是为了适配底层的设备。
```

- IP 协议可能会遇到的几个问题（ IP 协议并不会去处理这些问题，因为网络层只专注解决网络层的问题， 而且不同特性的应用在不同场景下需要解决的问题不一样）

```
- 封包损坏（数据传输过程中被损坏）
- 丢包（数据发送过程中丢失）
- 重发（数据被重发，比如中间设备通过 2 个路径传递数据）
- 乱序（到达目的地时数据和发送数据不一致）
```

- 数据在网络中交换（封包交换算法），并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助数据封包选择下一个目的地。



# 第二章 IPv4 协议

## 1、什么是 IPv4 协议

- IPv4 就是 IP 协议的第 4 个版本，是目前互联网的主要网络层协议。
- IPv4 为传输层提供 Host-To-Host 的能力
- IPv4 需要底层数据链路层的支持。



## 2、IPv4 协议的工作原理

- IP 协议接收 IP 协议上方的 Host-To-Host 协议传来的数据，然后进行拆分，这个能力叫作分片（Fragmentation）
- 然后 IP 协议为每个片段（Fragment）增加一个 IP 头（Header），组成一个IP 封包（Datagram）
- 之后，IP 协议调用底层的局域网（数据链路层）传送数据
- 最后 IP 协议通过寻址和路由能力最终把封包送达目的地



### 2.1 分片（Fragmentation）

- 分片就是把数据切分成片。 
- IP 协议通过它下层的局域网（链路层）协议传输数据，因此需要适配底层传输网络的传输能力。数据太大通常就不适合底层网络传输，这就需要把大的数据切片。 
- 当然也可能选择不切片，IP 协议提供了一个能力就是把封包标记为不切片，当底层网络看到不切片的封包，又没有能力传输的时候，就会丢弃这个封包。
- 你要注意，在网络环境中往往存在多条路径，一条路径断了，说不定其他路径可以连通。



### 2.2 增加协议头（IP Header）

- 切片完成之后，IP 协议会为每个切片（数据封包 Datagram）增加一个协议头
- IPv4 的地址是 4 组 8 位的数字，总共是 32 位

![image-20210818084810172](image/image-20210818084810172.png)

#### （1）IHL（Internet Header Length）

- 用来描述 IP 协议头的大小

- IP 协议头的大小是可变的
- IHL 只有 4 位，最大值 1111 = 15。最大是 15 个双字（15*4 字节 = 60 字节）



#### （2）Type Of Service 

- 服务的类型（是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系）

- 延迟（latency）

```
- 延迟指的是 1 bit 的数据从网络的一个终端传送到另一个终端需要的时间
- 这个时间包括在发送端准备发送的时间、排队发送的时间、发送数据的时间、数据传输的时间等
```

- 吞吐量（Throughput）

```
- 吞吐量指单位时间内可以传输的平均数据量
- 比如用 bit/s 作为单位，就是 bps

- 吞吐量和延迟没有联系
- 比如延迟很高的网络，有可能吞吐量很高。可以类比成水管很大流速很慢，对比水管很细流速很快，这两种情况，最终流量可以是相等的。
```

- 丢包率（Packet loss）

```
- 丢包率指发送出去的封包没有到达目的地的比例
- 在最大流速确定的网络中，丢包率会直接影响吞吐量
```



- 这三个条件，通常不能同时满足。如果同时追求延迟、吞吐量、丢包率，那么对网络设备的要求就会非常高，说白了就会非常贵。因此 IP 协议头中的 Type of Service 字段里，有以下 4 种主要的类型可以选择
  - 低延迟
  - 高吞吐量
  - 低丢包率
  - 低成本



#### （3）Total Length

- 定义报文（封包 Datagram）的长度



#### （4）Identification

- 报文的 ID

- 发送方分配，代表顺序



#### （5）Fragment offset 

- 描述要不要分包（拆分），以及如何拆分



#### （6）Time To Live

- 描述封包存活的时间
- 因此每个 IP 封包发送出去后，就开始销毁倒计时。
- 如果倒计时为 0，就会销毁。
- 比如中间的路由器看到一个 TTL 为 0 的封包，就直接丢弃。



#### （7）Protocol 

- 描述上层的协议，比如 TCP = 6，UDP = 17



#### （8）Checksum 

- 用来检验封包的正确性
- 如果 Checksum 对不上，就需要选择丢弃这个封包



#### （9）Source address

- 原地址



#### （10）Destination address

- 目标地址

  

#### （11）Options

- 代表可选项



### 2.3 寻址（Addressing）

- 地址想要表达的是一个东西在哪里
- 寻址要做的就是：给一个地址，然后找到这个东西
- IPv4 协议的寻址过程是逐级寻址



#### （1）IPv4 地址格式

- Pv4 地址是 4 个 8 位（Octet）排列而成，总共可以编址 43 亿个地址

```
- 比如 103.16.3.1 就是一个合法的 Ipv4 地址
- 4 组数字用.分开，是为了让人可读，实际上在内存和传输过程中，就是直接用 32 位

  103        16         3        1
01100111  00010000  00000011 00010001
```



#### （2）寻址过程

- 寻址就是如何根据 IP 地址找到设备
- IP 协议的寻址过程需要逐级找到网络，最后定位设备
- 因为 IPv4 的世界中，网络是一个树状模型。顶层有多个平行的网络，每个网络有自己的网络号。然后顶层网络下方又有多个子网，子网下方还有子网，最后才是设备。

![image-20210818090723712](image/image-20210818090723712.png)



##### 步骤 1：找到顶层网络

- 比如 103.16.3.1 最顶层的网络号可以和 255.0.0.0（子网掩码）做位与运算得到

```bash
# 103.0.0.0 就是 103.16.3.1 所在的顶层网络
103.16.3.1 & 255.0.0.0 = 103.0.0.0 
```

- 255.0.0.0.称作子网掩码

```
- 子网掩码的作用：根据 IP 地址找到对应子网
- 子网掩码是很多个1接着很多个0，和 IP 地址一起使用
```



##### 步骤 2：找到下一层网络

- 接下来要找到下一级网络，就需要用 IP 地址和下一级的子网掩码做位与运算。

```bash
# 103.16.0.0就是下一级的网络号
103.16.3.1 & 255.255.0.0 = 103.16.0.0
```



##### 步骤 3：找到再下一级网络

- 接下来使用 255.255.255.0 子网掩码找到下一级网络是103.16.3.0



##### 步骤 4：定位设备

- 设备就在子网103.16.3.0中，最终找到的设备号是1

- 当然子网掩码也不一定都是255，比如这个子网掩码 255.240.0.0 也是可以的



### 2.4 路由（Routing）

- 在寻址过程中，数据总是存于某个局域网中。如果目的地在局域网中，就可以直接定位到设备了。如果目的地不在局域网中，这个时候，就需再去往其他网络。

- 由于网络和网络间是网关在连接，因此如果目的地 IP 不在局域网中，就需要为 IP 封包选择通往下一个网络的路径，其实就是选择其中一个网关。

![image-20210818094347653](image/image-20210818094347653.png)



- 假如，我们要为 IP 地址 14.215.177.38 寻址
- 当前路由器所在的网络的编号是16.0.0.0
- 那么我们就需要知道去往 14.0.0.0 网络的 Gateway IP 地址



- 如果你在当前网络中用 route 查看路由表，可能可以看到一条下面这样的记录

```bash
Destination：14.0.0.0
Gateway：16.12.1.100
Mask：255.0.0.0
Iface：16.12.1.1
```

- 这条记录就说明如果你要去往 14.0.0.0 网络，IP 地址 14.215.177.38 先要和 255.0.0.0 进行位运算，然后再查表，看到 14.0.0.0，得知去往 Gateway 的网卡（IFace）是 16.12.1.1。

- 当封包去向下一个节点后，会进入新的路由节点，然后会继续上述路由过程，直到最终定位到设备



## 3、总结

- 首先 IP 协议会进行分片，将上游数据拆成一个个的封包（Datagram），然后为封包增加 IP 头部。封包发送出去后，就开始了寻址过程。寻址就是找到 IP 地址对应的设备。在局域网内，如果找不到设备，就需要路由。路由就是找到数据应该往哪里发送。最后通过层层路由定位到具体的设备。



## 【面试题】路由和寻址的区别是什么？

```
【解析】
- 寻址（Addressing）就是通过地址找设备
- 和现实生活中的寻址是一样的，比如根据地址找到一个公寓。
- 在 IPv4 协议中，寻址找到的是一个设备所在的位置。

- 路由（Routing）本质是路径的选择
- 就好像知道地址，但是到了每个十字路口，还需要选择具体的路径。
- 所以，要做路由，就必须能够理解地址，也就是需要借助寻址的能力。要通过寻址找到最终的设备，又要借助路由在每个节点选择数据传输的线路

- 因此，路由和寻址，是相辅相成的关系。
```



# 第三章 IPv6 协议

## 1、IPv6 的引入

- IPv4 用 32 位整数描述地址，最多只能支持 43 亿设备，显然是不够用的，这也被称作 IP 地址耗尽问题。
- 为了解决这个问题，1998 年互联网工程工作小组推出了全新款的 IP 协议——IPv6 协议。

- 作为网络层协议的 IPv6，最核心的能力是确保数据可以从发送主机到达接收主机。
- IPv6 解决的是地址耗尽的问题

```
因为解决了地址耗尽的问题，所以很多其他问题也得到了解决，比如说减少了子网，更小的封包头部体积，最终提升了性能等
```



## 2、IPv6 协议的工作原理

- 接收上方主机到主机（Host-to-Host）协议传递来的数据，比如一个 TCP 段（Segment）
- 然后将 TCP 段再次切片做成一个个的 IPv6 封包（Datagram or Packet）
- 再调用底层局域网能力（数据链路层）传输数据

![image-20210819085941435](image/image-20210819085941435.png)



### 2.1 切片（Segmentation）



### 2.2 增加封包头



### 2.3 寻址

#### （1）IPv6 地址格式

- 位数
  - IPv4 的地址是 4 个 8 位（octet），总共 32 位
  - IPv6 的地址是 8 个 16 位（hextet），总共 128 位



- 格式上
  - IPv4 的地址用.分割，如103.28.7.35。每一个是 8 位，用 0-255 的数字表示。
  - IPv6 的地址用:分割，如0123:4567:89ab:cdef:0123:4567:89ab:cdef，总共 8 个 16 位的数字，通常用 16 进制表示。

![image-20210819090736182](image/image-20210819090736182.png)



- Hexadecimal notation：十六进制表示
- Quartet：16 位
- Most significant：最高有效位
- Binary notation：二进制表示



- 简写形式

```bash
# 完全态写法
0123:4567:89ab:cdef:0123:4567:89ab:cdef

# 简写
0123:4567:0000:0000:0123:4567:0000:cdef

# 省略前 64 字节的0000:0000简写
0123:4567::0123:4567:0000:cdef

# 开头的 0 简写
123:4567::123:4567:0:cdef
```



#### （2）IPv6 寻址类型

- 和 IPv4 相同，IPv6寻址最核心的内容就是要对网络进行划分



##### 类型 1：全局单播寻址

- 和 IPv4 地址作用差不多，在互联网中通过地址查找一个设备，简单来说，单播就是 1 对 1）
- 全局单播，就是将消息从一个设备传到另一个设备，这和 IPv4 发送/接收消息大同小异。
- 全局单播地址，目标就是定位网络中的设备，这个地址和 IPv4 的地址作用相同，只不过格式略有差异。总的来说，IPv6 地址太多，因此不再需要子网掩码，而是直接将 IPv6 的地址分区即可

![image-20210819091456741](image/image-20210819091456741.png)

- 在实现全局单播时，IPv6 地址通常分成 3 个部分：

  - 站点前缀（Site Prefix），48bit

  ```
  一般是由 ISP（Internet Service Providor，运营商）或者RIR（Regional Internet Registry， 地区性互联网注册机构），RIR 将 IP 地址分配给运营商
  ```

  - 子网号（Subnet ID），16bit，用于站点内部区分子网；
  - 接口号（Interface ID）， 64bit，用于站点内部区分设备。



- 因此 IPv6 也是一个树状结构，站点前缀需要一定资质，子网号和接口号内部定义。IPv6 的寻址过程就是先通过站点前缀找到站点，然后追踪子网，再找到接口（也就是设备的网卡）。

- 从上面全局单播的分区，我们可以看出，IPv6 分给站点的地址非常多。一个站点，有 16bit 的子网，相当于 65535 个子网；每个子网中，还可以用 64 位整数表示设备。



##### 类型 2：本地单播

- 在局域网络中，实现设备到设备的通信，就是本地单播
- 本地单播地址必须以fe80开头，后面 64 位的 0，然后接上 54 位的设备编号。上图中的 Interface 可以理解成网络接口，其实就是网卡（类似 IPv4 里的一个内部网络，类似 IPv4 中127开头的地址）
- 理论上，虽然 IPv6 可以将所有的设备都连入一个网络。但在实际场景中，很多公司还是需要一个内部网络的。这种情况在 IPv6 的设计中属于局域网络。

![image-20210819091647849](image/image-20210819091647849.png)



##### 类型 3：分组多播（Group Multicast）

- 类似广播（就是将消息同时发送给多个接收者）

- IPv6 中设计了分组多播，来实现广播的能力。当 IP 地址以 8 个 1 开头，也就是ff00开头，后面会跟上一个分组的编号时，就是在进行分组多播。

- 这个时候，我们需要一个广播设备，在这个设备中已经定义了这些分组编号，并且拥有分组下所有设备的清单，这个广播设备会帮助我们将消息发送给对应分组下的所有设备。



##### 类型 4：任意播（Anycast）

- 任意播，本质是将消息发送给多个接收方，并选择一条最优的路径

- 比如说在一个网络中有多个授时服务，这些授时服务都共享了一个任播地址。当一个客户端想要获取时间，就可以将请求发送到这个任播地址。客户端的请求扩散出去后，可能会找到授时服务中的一个或者多个，但是距离最近的往往会先被发现。这个时候，客户端就使用它第一次收到的授时信息修正自己的时间。



### 2.4 路由



## 3、IPv6 和 IPv4 的兼容

### 情况 1：IPv4 网络和 IPv6 网络通信

- 一个 IPv4 的网络和一个 IPv6 的网络通信

![image-20210819091921892](image/image-20210819091921892.png)

- 步骤 1：客户端通过 DNS64 服务器查询 AAAA 记录。

```
- DNS64 是国际互联网工程任务组（IETF）提供的一种解决 IPv4 和 IPv6 兼容问题的 DNS 服务。
- 这个 DNS 查询服务会把 IPv4 地址和 IPv6 地址同时返回。
```

- 步骤 2：DNS64 服务器返回含 IPv4 地址的 AAAA 记录。
- 步骤 3：客户端将对应的 IPv4 地址请求发送给一个 NAT64 路由器
- 步骤 4：由这个 NAT64 路由器将 IPv6 地址转换为 IPv4 地址，从而访问 IPv4 网络，并收集结果。
- 步骤 5：消息返回到客户端。



### 情况 2：两个 IPv6 网络被 IPv4 隔离

- 一个 IPv6 的网络和一个 IPv6 的网络通信，但是中间需要经过一个 IPv4 的网络。
- 隧道的本质就是在两个 IPv6 的网络出口网关处，实现一段地址转换的程序。

![image-20210819092025148](image/image-20210819092025148.png)



## 【面试题】Tunnel 技术是什么？

```
【解析】
- Tunnel 就是隧道，这和现实中的隧道是很相似的。隧道不是只有一辆车通过，而是每天都有大量的车辆来来往往。

- 两个网络，用隧道连接，位于两个网络中的设备通信，都可以使用这个隧道。

- 隧道是两个网络间用程序定义的一种通道。具体来说，如果两个 IPv6 网络被 IPv4 分隔开，那么两个 IPv6 网络的出口处（和 IPv4 网络的网关处）就可以用程序（或硬件）实现一个隧道，方便两个网络中设备的通信。
```



