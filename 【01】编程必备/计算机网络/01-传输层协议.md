> 当前位置：【01】编程必备 -> 计算机网络 -> 01-传输层协议



# 第一章 TCP 协议

## 1、TCP 概念

- TCP（Transport Control Protocol）是一个==传输层协议==，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。



## 2、TCP 可靠性

- 可靠性指数据保证无损传输。
- 如果发送方按照顺序发送，然后数据无序地在网络间传递，就必须有一种算法在接收方将数据恢复原有的顺序。
- 另外，如果发送方同时要把消息发送给多个接收方，这种情况叫作==多播==，可靠性要求每个接收方都无损收到相同的副本。多播情况还有强可靠性，就是如果有一个消息到达任何一个接收者，那么所有接受者都必须收到这个消息。



## 3、TCP 的握手和挥手

- TCP 是一个连接导向的协议，设计有建立连接（握手）和断开连接（挥手）的过程。
- TCP ==没有设计会话（Session）==，因为会话通常是一个应用的行为。



### 3.1 TCP 协议的基本操作

- 如果一个 Host 主动向另一个 Host 发起连接，称为 ==SYN==（Synchronization），==请求同步==

- 如果一个 Host 主动断开请求，称为 ==FIN==（Finish），==请求完成==
- 如果一个 Host 给另一个 Host 发送数据，称为 ==PSH==（Push），==数据推送==

- 以上 3 种情况，接收方收到数据后，都需要给发送方一个==ACK（Acknowledgement）响应==。请求/响应的模型是可靠性的要求，如果一个请求没有响应，发送方可能会认为自己需要重发这个请求。



### 3.2 建立连接的过程（三次握手）

- 第一次握手
  - 客户端发消息给服务端（SYN）

服务端准备好进行连接

- 第二次握手
  - 服务端针对客户端的 SYN 给一个 ACK
  - 服务端发送一个 SYN 给客户端

客户端准备就绪

- 第三次握手
  - 客户端给服务端发送一个 ACK

![Snip20210812_73](image/Snip20210812_73.png)

### 3.3 断开连接的过程（4 次挥手）

- 第一次挥手
  - 客户端要求断开连接，发送一个断开的请求，这个叫作（FIN）

- 第二次挥手
  - 服务端收到请求，然后给客户端一个 ACK，作为 FIN 的响应。

```
这里你需要思考一个问题，可不可以像握手那样马上传 FIN 回去？
- 其实这个时候服务端不能马上传 FIN，因为断开连接要处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。
- 因此断开连接不能像握手那样操作——将两条消息合并。
```

- 第三次挥手
  - 服务端经过一个等待，确定可以关闭连接了，再发一条 FIN 给客户端。

- 第四次挥手
  - 客户端收到服务端的 FIN，同时客户端也可能有自己的事情需要处理完，比如客户端有发送给服务端没有收到 ACK 的请求，客户端自己处理完成后，再给服务端发送一个 ACK。

![image-20210812103217895](image/image-20210812103217895.png)



### 总结

```
TCP 提供连接（Connection），让双方的传输更加稳定、安全。

TCP 没有直接提供会话，因为应用对会话的需求多种多样，比如聊天程序会话在保持双方的聊天记录，电商程序会话在保持购物车、订单一致，所以会话通常在 TCP 连接上进一步封装，在应用层提供。

TCP 是一个面向连接的协议（Connection -oriented Protocol），说的就是 TCP 协议参与的双方（Host）在收发数据之前会先建立连接。后面我们还会学习 UDP 协议，UDP 是一个面向报文（Datagram-oriented）的协议——协议双方不需要建立连接，直接传送报文（数据）。

最后，连接需要消耗更多的资源。比如说，在传输数据前，必须先协商建立连接。因此，不是每种场景都应该用连接导向的协议。像视频播放的场景，如果使用连接导向的协议，服务端每向客户端推送一帧视频，客户端都要给服务端一次响应，这是不合理的。
```



### 面试题：TCP 为什么是 3 次握手，4 次挥手

```
【解析】TCP 是一个双工协议，为了让双方都保证，建立连接的时候，连接双方都需要向对方发送 SYC（同步请求）和 ACK（响应）。

握手阶段双方都没有烦琐的工作，因此一方向另一方发起同步（SYN）之后，另一方可以将自己的 ACK 和 SYN 打包作为一条消息回复，因此是 3 次握手——需要 3 次数据传输。

到了挥手阶段，双方都可能有未完成的工作。收到挥手请求的一方，必须马上响应（ACK），表示接收到了挥手请求。类比现实世界中，你收到一个 Offer，出于礼貌你先回复考虑一下，然后思考一段时间再回复 HR 最后的结果。最后等所有工作结束，再发送请求中断连接（FIN），因此是 4 次挥手
```



# 第二章 TCP 拆包和粘包

## 1、缓冲区

- 为了稳定性，一次发送的数据越多，出错的概率越大
- 为了效率，网络中有时候存在着并行的路径，拆分数据包就能更好地利用这些并行的路径
- 发送和接收数据的时候，都存在着缓冲区

```
- 缓冲区是在内存中开辟的一块区域，目的是缓冲。
- 因为大量的应用频繁地通过网卡收发数据，这个时候，网卡只能一个一个处理应用的请求。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。
- 如果每个应用都随意发送很大的数据，可能导致其他应用实时性遭到破坏。
```



![image-20210813091654865](image/image-20210813091654865.png)



## 2、拆包

- 在 TCP 协议的设计当中，数据被拆分成很多个部分，部分增加了协议头。合并成为一个 TCP 段，进行传输。这个过程，我们俗称拆包。这些 TCP 段经过复杂的网络结构，由底层的 IP 协议，负责传输到目的地，然后再进行重组。
- 拆包是将数据拆分成多个 TCP 段传输



## 3、粘包

- 有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目的地再还原成多个数据，这个过程俗称粘包。
- 粘包是将多个数据合并成一个 TCP 段发送。



## 4、TCP 段（TCP Segment）

- 在传输层封包不能太大。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 TCP 段（TCP Segment）。
- TCP 协议就是依靠每一个 TCP 段工作的。

![image-20210813092116693](image/image-20210813092116693.png)



### （1）Source Port/Destination Port 

- 描述的是发送端口号和目标端口号，代表发送数据的应用程序和接收数据的应用程序。
- 比如 80 往往代表 HTTP 服务，22 往往是 SSH 服务……
- 类比快递包裹的发件人地址 和 收件人地址



### （2）Sequence Number 和 Achnowledgment Number 

- 保证可靠性的两个关键
- 类比快递包裹的编号

```
- 发出的每一个 TCP 段都需要有序号 Sequence Number（Seq）
- 发送数据的时候，为每一个 TCP 段分配一个自增的 Sequence Number
- 接收数据的时候，虽然得到的是乱序的 TCP 段，但是可以通过 Seq 进行排序
```



### （3）Data Offset

- 一个偏移量。
- 这个量存在的原因是 TCP Header 部分的长度是可变的，因此需要一个数值来描述数据从哪个字节开始。

- 类比快递包裹的大小



### （4）Reserved

- 很多协议设计会保留的一个区域，用于日后扩展能力。



### （5）URG/ACK/PSH/RST/SYN/FIN

- 标志位，用于描述 TCP 段的行为（也就是一个 TCP 封包到底是做什么用的）

```
- URG 代表这是一个紧急数据，比如远程操作的时候，用户按下了 Ctrl+C，要求终止程序，这种请求需要紧急处理。
- ACK 代表响应，所有的消息都必须有 ACK，这是 TCP 协议确保稳定性的一环。
- PSH 代表数据推送，也就是在传输数据的意思。
- SYN 同步请求，也就是申请握手。
- FIN 终止请求，也就是挥手。

特别说明一下：以上这 5 个标志位，每个占了一个比特，可以混合使用。比如 ACK 和 SYN 同时为 1，代表同步请求和响应被合并了。这也是 TCP 协议，为什么是三次握手的原因之一。
```



### （6）Window

- TCP 保证稳定性并进行流量控制的工具
- 类比快递包裹的运输方式（空运、陆运、水运）



### （7）Checksum

- 校验和，用于校验 TCP 段有没有损坏。

- 类比检查快递包裹有没有被拆过



### （8）Urgent Pointer

- 指向最后一个紧急数据的序号（Sequence Number）。
- 它存在的原因是：有时候紧急数据是连续的很多个段，所以需要提前告诉接收方进行准备。

- 类比快递包裹是一个加急快件



### （9）Options（如 MMS）

- 存储了一些可选字段，比如 MSS（Maximun Segment Size）。

```
- TCP Header 中的可选项（Options）
- MSS 可选项控制了 TCP 段的大小，它是一个协商字段（Negotiate）。
- TCP 段的大小（MSS）涉及发送、接收缓冲区的大小设置，双方实际发送接收封包的大小，对拆包和粘包的过程有指导作用，因此需要双方去协商

- 如果这个字段设置得非常大，就会带来一些影响。（因为大的 TCP 段，会降低性能，比如内存使用的性能。）
- MSS 太小的情况下，会浪费传输资源（降低吞吐量）。因为数据被拆分之后，每一份数据都要增加一个头部。如果 MSS 太小，那头部的数据占比会上升，这让吞吐量成为一个灾难。
```



### （10）Padding 

- 因为 Options 的长度不固定，需要 Pading 进行对齐。



## 5、面试题

- TCP 协议是如何恢复数据的顺序的，TCP 拆包和粘包的作用是什么？

```
【解析】
- TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。
- 拆包过程需要保证数据经过网络的传输，又能恢复到原始的顺序。这中间，需要数学提供保证顺序的理论依据。
- TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。
- 粘包是为了防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。
```



# 第三章 TCP 滑动窗口算法（请求/响应模型演变）

## 3.1 请求 - 响应

```
- 每一个请求收到响应之后，再发送下一个请求，吞吐量会很低。
- 因为这样的设计，会产生网络的空闲时间（浪费带宽）
- 带宽没有用满，意味着可以同时发送更多的请求，接收更多的响应
```



![image-20210816094504496](image/image-20210816094504496.png)



## 3.2 请求 响应

```
- 让发送方有请求就发送出去，而不是等待响应。
- 通过这样的处理方式，发送的数据连在了一起，响应的数据也连在了一起，吞吐量就提升了。

- 但是如果可以同时发送的数据真的非常多呢？比如成百上千个 TCP 段都需要发送，这个时候带宽可能会不足
```

![image-20210816094722715](image/image-20210816094722715.png)



## 3.3 排队（Queuing）

```
- 在 TCP 层实现一个队列。新元素从队列的一端（左侧）排队，作为一个未发送的数据封包。开始发送的数据封包，从队列的右侧离开

- 这样做就需要多个队列，要将未发送的数据从队列中取出，加入发送中的队列。然后再将发送中的数据，收到 ACK 的部分取出，放入已接收的队列。而发送中的封包，何时收到 ACK 是一件不确定的事情，这样使用队列似乎也有一定的问题。
```

![image-20210816094906032](image/image-20210816094906032.png)

## 3.4 滑动窗口（Sliding Window）

### （1）简介

- TCP 作为一个传输层协议，最核心的能力是传输。(TCP 协议控制可靠性的核心)
- 传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供。

- 滑动窗口中使用场景

```
- 比如设计一个分布式的 RPC 框架
- 实现一个消息队列
- 实现分布式的文件系统等
```



### （2）滑动窗口（是一种数据结构）

```
- 深绿色代表已经收到 ACK 的段
- 浅绿色代表发送了，但是没有收到 ACK 的段
- 白色代表没有发送的段
- 紫色代表暂时不能发送的段
```

![image-20210816095313725](image/image-20210816095313725.png)



- 下面重新设计一下不同类型封包的顺序

  - 将已发送的数据放到最左边
  - 发送中的数据放到中间
  - 未发送的数据放到右边

  

- 假设最多同时发送 5 个封包，也就是窗口大小 = 5。窗口中的数据被同时发送出去，然后等待 ACK。

  - 如果一个封包 ACK 到达，就将它标记为已接收（深绿色）



- 如下图所示，有两个封包的 ACK 到达，因此标记为绿色。

![image-20210816095653931](image/image-20210816095653931.png)

- 这个时候滑动窗口可以向右滑动，如下图所示

![image-20210816095832101](image/image-20210816095832101.png)



### （3）重传

- 如果发送过程中，部分数据没能收到 ACK ，就可能发生重传

- 如果发生下图这样的情况，段 4 迟迟没有收到 ACK

![image-20210816095917385](image/image-20210816095917385.png)

- 这个时候滑动窗口只能右移一个位置，如下图所示：

```
- 在这个过程中，如果后来段 4 重传成功（接收到 ACK），那么窗口就会继续右移
- 如果段 4 发送失败，还是没能收到 ACK，那么接收方也会抛弃段5、段6、段7
- 这样从段 4 开始之后的数据都需要重发。
```

![image-20210816095946724](image/image-20210816095946724.png)





### （4）快速重传

- 在 TCP 协议中，如果接收方想丢弃某个段，可以选择不发 ACK
- 发送端超时后，会重发这个 TCP 段。
- 而有时候，接收方希望催促发送方尽快补发某个 TCP 段，这个时候可以使用==快速重传==。

```
- 例如段1、段2、段4 到了，但是段3没有到
- 接收方可以发送多次段3的 ACK
- 如果发送方收到多个段3的 ACK，就会重发段3。这个机制称为快速重传。这和超时重发不同，是一种催促的机制。

- 为了不让发送方误以为段3已经收到了，在快速重传的情况下，接收方即便收到发来的段4，依然会发段3的 ACK（不发段4的 ACK），直到发送方把段3重传。
```



### （5）流速控制

- 每个 TCP 段的大小不同，限制数量会让接收方的缓冲区不好操作，因此实际操作中窗口大小单位是字节数。
- 发送、接收窗口的大小可以用来控制 TCP 协议的流速。

```
- 窗口越大，同时可以发送、接收的数据就越多，支持的吞吐量也就越大
- 当然，窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据
```



- 举个例子

```
用 RTT 表示 Round Trip Time，就是消息一去一回的时间

假设 RTT = 1ms，带宽是 1mb/s。
如果窗口大小为 1kb，那么 1ms 可以发送一个 1kb 的数据（含 TCP 头），1s 就可以发送 1mb 的数据，刚好可以将带宽用满。
如果 RTT 再慢一些，比如 RTT = 10ms，那么这样的设计就只能用完 1/10 的带宽。 
当然可以提高窗口大小提高吞吐量，但是实际的模型会比这个复杂，因为还存在重传、快速重传、丢包等因素。

而实际操作中，也不可以真的把带宽用完，所以最终会使用折中的方案，在延迟、丢包率、吞吐量中进行选择，毕竟鱼和熊掌不可兼得。
```



## 面试题：滑动窗口和流速控制是怎么回事？

```
滑动窗口是 TCP 协议控制可靠性的核心。发送方将数据拆包，变成多个分组。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的分组会一次性发送。窗口中序号最小的分组如果收到 ACK，窗口就会发生滑动；如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送。

另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速
```



# 第四章 UDP 协议

