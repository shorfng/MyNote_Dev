> 当前位置：【Java】02_Pattern（设计模式）-> 2.0_Principle（软件架构设计原则）



## 软件架构设计原则（7种）



## 1、开闭原则（Open Close Principle，OCP）

### 1.1 开闭原则 - 定义

- 开闭原则是指一个软件实体（如类、模块和函数）应该对扩展开放，对修改关闭（需要使用接口和抽象类）

- 在程序需要进行扩展的时候，不能去修改原有的代码，实现一个热插拔的效果
- 强调的是用抽象构建框架，用实现扩展细节
- 实现开闭原则的核心思想是：面向抽象编程

### 1.2 开闭原则 - 优点

- 提高软件系统的可复用性
- 使程序的扩展性更好，易于维护和升级  

### 1.3 开闭原则 - 应用场景

- 开发中：版本更新，尽可能不修改源代码，但是可以增加新功能
- 生活中：很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是什么时候来，什么时候走是开放的，早来早走，晚来晚走

### 1.4 开闭原则 - 案例

#### （1）ICourse.java（课程接口）

```java
public interface ICourse {
    Integer getId();

    String getName();

    Double getPrice();
}
```

#### （2）JavaCourse.java（java课程类）

```java
public class JavaCourse implements ICourse{
    private Integer id;   // 课程id
    private String name;  // 课程标题
    private Double price; // 价格
....
```

#### （3）JavaDiscountCourse.java（java课程打折类）

```java
public class JavaDiscountCourse extends JavaCourse {
    public JavaDiscountCourse(Integer id, String name, Double price) {
        super(id, name, price);
    }

    // 得到原始价格
    public Double getOriginPrice() {
        return super.getPrice();
    }

    // 得到打折价格
    public Double getDiscountPrice() {
        return super.getPrice() * 0.61;
    }
}
```

#### （4）OpenCloseTest.java

```java
public class OCPTest {
    public static void main(String[] args) {
        JavaCourse javaCourse = new JavaCourse(1, "java架构课程", 18888.00);
        System.out.println("课程id：" + javaCourse.getId());
        System.out.println("课程标题：" + javaCourse.getName());
        System.out.println("价格：" + javaCourse.getPrice());

        System.out.println("==================================");

        JavaDiscountCourse javaDiscountCourse = new JavaDiscountCourse(2, "java架构课程（打折）", 18888.00);
		System.out.println("课程id：" + javaDiscountCourse.getId());
		System.out.println("课程标题：" + javaDiscountCourse.getName());
		System.out.println("原始价格：" + javaDiscountCourse.getOriginPrice());
        System.out.println("折后价格：" + javaDiscountCourse.getDiscountPrice());
    }
}
```

#### （5）测试结果

```java
课程id：1
课程标题：java架构课程
价格：18888.0
==================================
课程id：2
课程标题：java架构课程（打折）
原始价格：18888.0
折后价格：11521.68
```



## 2、依赖倒置原则（Dependence Inversion Principle，DIP）

### 2.1 依赖倒置原则 - 定义

- 依赖倒置原则是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象（细节应该依赖抽象）
- 总结：针对接口编程，依赖于抽象而不依赖于具体
- 注意：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此在拿到需求之后，要面向接口编程，先顶层再细节来设计代码结构 

### 2.2 依赖倒置原则 - 优点

- 减少类与类之间的耦合性
- 提高系统的稳定性
- 提高代码的可读性和可维护性
- 能够降低修改程序所造成的风险 

### 2.3 依赖倒置原则 - 实现方式

- 依赖注入
- 构造器注入
- 单例下，setter方式注入

### 2.4 依赖倒置原则 - 案例



#### （1）ICourse.java（课程接口）

```java
public interface ICourse {
	void study();
}
```

#### （2）JavaCourse.java（课程实现类）

```java
public class JavaCourse implements ICourse {
	@Override
	public void study() {
		System.out.println("TD 在学习 Java 的课程");
	}
}
```

#### （3）PythonCourse.java（课程实现类）

```java
public class PythonCourse implements ICourse {
	@Override
	public void study() {
		System.out.println("TD 在学习 Python 的课程");
	}
}
```

#### （4）Student.java（学生类）

- 传统写法

```java
public class Student {
	public Student() {
	}

	// 传统写法
	public void studyJavaCourse() {
		System.out.println("TD 在学习 Java 的课程");
	}

	public void studyPythonCourse() {
		System.out.println("TD 在学习 Python 的课程");
	}
}
```

- 实现依赖倒置原则的方式1：依赖注入

```java
public class Student {
	public Student() {
	}

	public void study(ICourse course) {
		course.study();
	}
}
```

- 实现依赖倒置原则的方式2：构造器

```java
public class Student {
	public Student() {
	}

	private ICourse iCourse;

	public Student(ICourse iCourse) {
		this.iCourse = iCourse;
	}

	public void study(){
		iCourse.study();
	}
}
```

- 实现依赖倒置原则的方式3：单例下，setter方式注入

```java
public class Student {
	public Student() {
	}

	private ICourse course;

	public void setCourse(ICourse course) {
		this.course = course;
	}

	public void study(){
		course.study();
	}
}
```

#### （5）测试

- 传统写法

```java
public class DIPTest {
	public static void main(String[] args) {
		// 传统写法
		System.out.println("======== 传统写法 ======== ");
		Student stu1 = new Student();
		stu1.studyJavaCourse();
		stu1.studyPythonCourse();
	}
}
```

- 实现依赖倒置原则的方式1：依赖注入

```java
public class DIPTest {
	public static void main(String[] args) {
		System.out.println("======== 实现依赖倒置原则的方式1：依赖注入 ======== ");
		Student stu2 = new Student();
		stu2.study(new JavaCourse());
		stu2.study(new PythonCourse());
	}
}
```

- 实现依赖倒置原则的方式2：构造器

```java
public class DIPTest {
	public static void main(String[] args) {
		System.out.println("======== 实现依赖倒置原则的方式2：构造器 ======== ");
		Student stu3 = new Student(new JavaCourse());
		stu3.study();

		Student stu4 = new Student(new PythonCourse());
		stu4.study();
	}
}
```

- 实现依赖倒置原则的方式3：单例下，setter方式注入

```java
public class DIPTest {
	public static void main(String[] args) {
		System.out.println("======== 实现依赖倒置原则的方式：单例下，setter方式注入 ======== ");
		Student stu5 = new Student();
		stu5.setCourse(new JavaCourse());
		stu5.study();

		stu5.setCourse(new PythonCourse());
		stu5.study();
	}
}
```



## 3、单一职责原则（Simple Responsibility Pinciple，SRP）

### 3.1 单一职责原则 - 定义

- 单一职责原则是指不要存在多于一个导致类变更的原因
- 假设场景：假设有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个Class 存在两个导致类变更的原因。如何解决这个问题呢？
- 解决方法：给两个职责分别用两个 Class 来实现，进行解耦，后期需求变更维护互不影响
- 总结：一个 Class/Interface/Method 只负责一项职责 

### 3.2 单一职责原则 - 优点

- 降低类的复杂度
- 提高类的可读性
- 提高系统的可维护性
- 降低变更引起的风险



### 3.3 单一职责原则 - 案例

#### （1）一个 class 只负责一项职责

- Course.java（课程类）

```java
public class Course {
	public void study(String courseName) {
		if ("直播课".equals(courseName)) {
			System.out.println("不能快进");
		} else {
			System.out.println("可以任意的来回播放");
		}
	}
}
```

- LiveCourse.java（直播课程，类层面的单一职责原则）

```java
public class LiveCourse {
	public void study(String courseName) {
		System.out.println("不能快进");
	}
}
```

- RecordCourse.java（录播课程，类层面的单一职责原则）

```java
public class RecordCourse {
	public void study(String courseName) {
		System.out.println("可以任意的来回播放");
	}
}
```

#### （2）一个 interface 只负责一项职责

- ICourse.java（课程接口）

```java
public interface ICourse {
	// 展示职责
	String getCourseName();  // 获取课程名
	byte[] getCourseVideo(); // 获取课程的视频

	// 权限职责
	void studyCourse();   // 学习课程的权限
	void refundCourse();  // 退费课程的权限
}
```

- ICourseInfo.java（课程的展示，接口层面的单一职责原则）

```java
public interface ICourseInfo {
	// 展示职责
	String getCourseName();  // 获取课程名
	byte[] getCourseVideo(); // 获取课程的视频
}
```

- ICourseManager.java（课程的权限，接口层面的单一职责原则）

```java
public interface ICourseManager {
	// 权限职责
	void studyCourse();   // 学习课程的权限
	void refundCourse();  // 退费课程的权限
}
```

- CourseImpl.java（课程的实现类）

```java
public class CourseImpl implements ICourseInfo, ICourseManager {
	@Override
	public String getCourseName() {
		return null;
	}

	@Override
	public byte[] getCourseVideo() {
		return new byte[0];
	}

	@Override
	public void studyCourse() {
	}

	@Override
	public void refundCourse() {
	}
}
```

#### （3）一个 method 只负责一项职责

- Method.java（方法层面的单一职责原则）

```java
public class Method {
	private void modifyUserInfo(String userName, String address) {
		userName = "TD";
		address = "Beijing";
	}

	// 使用单一职责原则后，解耦
	private void modifyUserName(String userName) {
		userName = "TD";
	}

	private void modifyAddress(String address) {
		address = "Beijing";
	}
}
```



## 4、接口隔离原则（Interface Segregation Principle，ISP）

### 4.1 接口隔离原则 - 定义

- 指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口



- 注意

- 一个类对一类的依赖应该建立在最小的接口之上。
- 建立单一接口，不要建立庞大臃肿的接口。
- 尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。

### 4.2 接口隔离原则 - 优点 

- 符合高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。

### 4.3 接口隔离原则 - 案例

#### （1）不使用接口隔离原则

![Diagrams](image/Diagrams.png)

- IAnimal.java

```java
public interface IAnimal {
    void eat();

    void fly();

    void swim();
}
```

- Dog.java

```java
public class Dog implements IAnimal {
    @Override
    public void eat() {
        // Do nothing
    }

    @Override
    public void fly() {
        // Do nothing
    }

    @Override
    public void swim() {
        // Do nothing
    }
}
```

- Bird.java

```java
public class Bird implements IAnimal {
    @Override
    public void eat() {
        // Do nothing
    }

    @Override
    public void fly() {
        // Do nothing
    }

    @Override
    public void swim() {
        // Do nothing
    }
}
```

#### （2）使用接口隔离原则

![Diagrams](image/Diagrams-16503335960771.png)

- IEatAnimal.java

```java
public interface IEatAnimal {
    void eat();
}
```

- IFlyAnimal.java

```java
public interface IFlyAnimal {
    void fly();
}
```

- ISwimAnimal.java

```java
public interface ISwimAnimal {
    void swim();
}
```

- Dog.java

```java
public class Dog implements ISwimAnimal, IEatAnimal {
    @Override
    public void eat() {
        // Do nothing
    }

    @Override
    public void swim() {
        // Do nothing
    }
}
```

- Bird.java

```java
public class Bird implements IEatAnimal, IFlyAnimal {
    @Override
    public void eat() {
        // Do nothing
    }

    @Override
    public void fly() {
        // Do nothing
    }
}
```



## 5、迪米特法则（Law of Demeter，LOD）

最少知道原则（Least Knowledge Principle，LKP）

- 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能 模块相对独立。



## 6、里氏替换原则（Liskov Substitution Principle，LSP）

- 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原 则中说，任何基类可以出现的地方，子类一定可以出现。 LSP 是继承复用的基石，只有当衍生类可以 替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增 加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而 基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。



## 7、合成复用原则（Composite/Aggregate Reuse Principle，CARP）

- 原则是尽量使用合成/聚合的方式，而不是使用继承。



